\paragraph{The Special Case of Syntactic Semantics}

The translation from \AR{Syntactic} to \AR{Semantics} uses a lot
of constructors as their own semantic counterpart, it is hence possible to generate
evidence of \AR{Syntactic} triplets being fusable with much fewer assumptions.
We isolate them and prove the result generically to avoid repetition. A
\AR{SyntacticFusable} record packs the evidence for
\AR{Syntactic} semantics \AB{syn^A}, \AB{syn^B} and \AB{syn^C}. It is indexed
by these three \AR{Syntactic}s as well as two relations corresponding to the
\AB{𝓥^R_{BC}} and \AB{𝓥^R} ones of the \AR{Fusable} framework.
It contains the same \ARF{𝓥^R‿∙}, \ARF{𝓥^R‿th} and \ARF{R⟦var⟧}
fields as a \AR{Fusable} as well as a fourth one (\ARF{var‿0^{BC}})
saying that \AB{syn^B} and \AB{syn^C}'s respective \ARF{var‿0}s are
producing related values.
\AgdaHide{
\begin{code}
record SyntacticFusable
  {ℓ^EA ℓ^EB ℓ^EC ℓ^REBC ℓ^RE : Level} {𝓥^A : Model ℓ^EA} {𝓥^B : Model ℓ^EB} {𝓥^C : Model ℓ^EC} (synA : Syntactic 𝓥^A)
  (synB : Syntactic 𝓥^B)
  (synC : Syntactic 𝓥^C)
  (𝓥^R‿BC : RModel 𝓥^B 𝓥^C ℓ^REBC)
  (𝓥^R : {Θ Δ Γ : Cx Ty} (ρ^A : (Γ -Env) 𝓥^A Δ) (ρ^B : (Δ -Env) 𝓥^B Θ) (ρ^C : (Γ -Env) 𝓥^C Θ) → Set ℓ^RE)
  : Set (ℓ^RE ⊔ ℓ^REBC ⊔ ℓ^EC ⊔ ℓ^EB ⊔ ℓ^EA)
  where
  module Syn^A = Syntactic synA
  module Syn^B = Syntactic synB
  module Syn^C = Syntactic synC
  field
    𝓥^R‿∙ : ({Γ Δ Θ : Cx Ty} {σ : Ty} {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ}
               {u^B : 𝓥^B σ Θ} {u^C : 𝓥^C σ Θ} (ρ^R : 𝓥^R ρ^A ρ^B ρ^C) (u^R : rmodel 𝓥^R‿BC u^B u^C) →
               𝓥^R (th[ Syn^A.th ] (step refl) ρ^A `∙ Syn^A.var‿0)
                      (ρ^B `∙ u^B)
                      (ρ^C `∙ u^C))
    𝓥^R‿th : {Γ Δ Θ E : Cx Ty} (inc : Θ ⊆ E)
               {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ} (ρ^R : 𝓥^R ρ^A ρ^B ρ^C) →
               𝓥^R ρ^A(th[ Syn^B.th ] inc ρ^B) (th[ Syn^C.th ] inc ρ^C)
    R⟦var⟧  : {Γ Δ Θ : Cx Ty} {σ : Ty} {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ}
              → (v : Var σ Γ) → 𝓥^R ρ^A ρ^B ρ^C →
              Eval.sem (syntactic synB) ρ^B (Eval.sem (syntactic synA) ρ^A (`var v))
              ≡ Eval.sem (syntactic synC) ρ^C (`var v)
\end{code}}
\begin{code}
    var‿0^BC : {Γ : Cx Ty} {σ : Ty} → rmodel 𝓥^R‿BC {σ} {Γ ∙ σ} Syn^B.var‿0 Syn^C.var‿0
\end{code}

\begin{theorem}[Fundamental Lemma of Fusable Syntactics]
Given a \AR{SyntacticFusable} relating three \AR{Syntactic} semantics,
we get a \AR{Fusable} relating the corresponding \AR{Semantics} where
\AB{𝓒^R} is the propositional equality.
\end{theorem}
\begin{proof}The proof relies on the way the translation from \AR{Syntactic}
to \AR{Semantics} is formulated in \cref{syntactic}.
\end{proof}
\AgdaHide{
\begin{code}
syntacticFusable :  {ℓ^EA ℓ^EB ℓ^EC ℓ^RE ℓ^REBC : Level} {𝓥^A : Model ℓ^EA} {𝓥^B : Model ℓ^EB} {𝓥^C : Model ℓ^EC} {syn^A : Syntactic 𝓥^A} {syn^B : Syntactic 𝓥^B} {syn^C : Syntactic 𝓥^C} {𝓥^R‿BC : RModel 𝓥^B 𝓥^C ℓ^REBC} {𝓥^R : {Θ Δ Γ : Cx Ty} (ρ^A : (Γ -Env) 𝓥^A Δ) (ρ^B : (Δ -Env) 𝓥^B Θ) (ρ^C : (Γ -Env) 𝓥^C Θ) → Set ℓ^RE} (syn^R : SyntacticFusable syn^A syn^B syn^C 𝓥^R‿BC 𝓥^R) →
  Fusable (syntactic syn^A) (syntactic syn^B) (syntactic syn^C) 𝓥^R‿BC 𝓥^R PropEq
syntacticFusable synF =
  let open SyntacticFusable synF in
  record
    { reify^A    = id
    ; 𝓥^R‿∙   = 𝓥^R‿∙
    ; 𝓥^R‿th  = 𝓥^R‿th
    ; R⟦var⟧    = R⟦var⟧
    ; R⟦$⟧      = λ f t eqf eqt ρ^R → PEq.cong₂ _`$_ eqf eqt
    ; R⟦λ⟧      = λ t r ρ^R → PEq.cong `λ (r (step refl) var‿0^BC)
    ; R⟦⟨⟩⟧     = λ ρ^R → PEq.refl
    ; R⟦tt⟧     = λ ρ^R → PEq.refl
    ; R⟦ff⟧     = λ ρ^R → PEq.refl
    ; R⟦if⟧   = λ b l r ρ^R eqb eql → PEq.cong₂ (uncurry `if) (PEq.cong₂ _,_ eqb eql)
    }

`var-inj : {Γ : Cx Ty} {σ : Ty} {pr₁ pr₂ : Var σ Γ} (eq : (Tm σ Γ F.∋ `var pr₁) ≡ `var pr₂) → pr₁ ≡ pr₂
`var-inj PEq.refl = PEq.refl
\end{code}}

\begin{corollary}[Renaming-Renaming fusion]Given two renamings \AB{ρ} from
\AB{Γ} to \AB{Δ} and \AB{ρ′} from \AB{Δ} to \AB{Θ} and a term \AB{t} of type
\AB{σ} with free variables in \AB{Γ}, we have that:
\AgdaHide{
\begin{code}
RenamingFusable :
  SyntacticFusable  syntacticRenaming syntacticRenaming syntacticRenaming
                    PropEq (λ ρ^A ρ^B ρ^C → ∀ σ pr → lookup (select ρ^A ρ^B) pr ≡ lookup ρ^C pr)
RenamingFusable = record
  { 𝓥^R‿∙     = λ ρ^R eq → [ eq ,, ρ^R ]
  ; 𝓥^R‿th    = λ inc ρ^R σ pr → PEq.cong (lookup inc) (ρ^R σ pr)
  ; R⟦var⟧    = λ v ρ^R → PEq.cong `var (ρ^R _ v)
  ; var‿0^BC  = PEq.refl }

ren-ren : {Γ Δ Θ : Cx Ty} {σ : Ty} (ρ : Γ ⊆ Δ) (ρ′ : Δ ⊆ Θ) (t : Tm σ Γ) → 
\end{code}}
%<*renren>
\begin{code}
 th^Tm σ ρ′ (th^Tm σ ρ t) ≡ th^Tm σ (ρ′ [∘] ρ) t
\end{code}
%</renren>
\AgdaHide{
\begin{code}
ren-ren ρ ρ′ t = let open Fusion (syntacticFusable RenamingFusable) in lemma t (λ _ _ → PEq.refl)
\end{code}}
\end{corollary}

\begin{corollary}[Renaming-Substitution fusion]Given a renaming \AB{ρ} from
\AB{Γ} to \AB{Δ}, a substitution \AB{ρ′} from \AB{Δ} to \AB{Θ} and a term
\AB{t} of type \AB{σ} with free variables in \AB{Γ}, we have that:\vspace*{ -1.5em}
\AgdaHide{
\begin{code}
RenamingSubstitutionFusable :
  SyntacticFusable syntacticRenaming syntacticSubstitution syntacticSubstitution
  PropEq (λ ρ^A ρ^B ρ^C → ∀ σ pr → lookup ρ^B (lookup ρ^A pr) ≡ lookup ρ^C pr)
RenamingSubstitutionFusable = record
  { 𝓥^R‿∙   = λ ρ^R eq → [ eq ,, ρ^R ]
  ; 𝓥^R‿th  = λ inc ρ^R σ pr → PEq.cong (th^Tm σ inc) (ρ^R σ pr)
  ; R⟦var⟧    = λ v ρ^R → ρ^R _ v
  ; var‿0^BC   = PEq.refl }

ren-sub : {Γ Δ Θ : Cx Ty} {σ : Ty} (ρ : Γ ⊆ Δ) (ρ′ : (Δ -Env) Tm Θ) (t : Tm σ Γ) → 
\end{code}}
%<*rensub>
\begin{code}
 subst ρ′ (th^Tm σ ρ t) ≡ subst (ρ′ [∘] ρ) t
\end{code}
%</rensub>
\AgdaHide{
\begin{code}
ren-sub ρ ρ′ t = let open Fusion (syntacticFusable RenamingSubstitutionFusable) in lemma t (λ _ _ → PEq.refl)
\end{code}}
\end{corollary}

\begin{corollary}[Substitution-Renaming fusion]Given a substitution \AB{ρ}
from \AB{Γ} to \AB{Δ}, a renaming \AB{ρ′} from \AB{Δ} to \AB{Θ} and a term
\AB{t} of type \AB{σ} with free variables in \AB{Γ}, we have that:\vspace*{ -1.5em}
\AgdaHide{
\begin{code}
SubstitutionRenamingFusable :
  SyntacticFusable syntacticSubstitution syntacticRenaming syntacticSubstitution
  (mkRModel (_≡_ ∘ `var)) (λ ρ^A ρ^B ρ^C → ∀ σ pr → th^Tm σ ρ^B (lookup ρ^A pr) ≡ lookup ρ^C pr)
SubstitutionRenamingFusable =
  let module RenRen = Fusion (syntacticFusable RenamingFusable) in
  record { 𝓥^R‿∙   = λ {_} {_} {_} {_} {ρ^A} {ρ^B} {ρ^C} ρ^R eq → [ eq ,, (λ σ pr →
                         PEq.trans (RenRen.lemma (lookup ρ^A pr) (λ _ _ → PEq.refl))
                                   (ρ^R σ pr)) ]
         ; 𝓥^R‿th  = λ inc {ρ^A} {ρ^B} {ρ^C} ρ^R σ pr →
                         PEq.trans (PEq.sym (RenRen.lemma (lookup ρ^A pr) (λ _ _ → PEq.refl)))
                                   (PEq.cong (th^Tm σ inc) (ρ^R σ pr))
         ; R⟦var⟧    = λ v ρ^R → ρ^R _ v
         ; var‿0^BC   = PEq.refl }
sub-ren : {Γ Δ Θ : Cx Ty} {σ : Ty} (ρ : (Γ -Env) Tm Δ) (ρ′ : Δ ⊆ Θ) (t : Tm σ Γ) → 
\end{code}}
%<*subren>
\begin{code}
 th^Tm σ ρ′ (subst ρ t) ≡ subst (map^Env (th^Tm _ ρ′) ρ) t
\end{code}
%</subren>
\AgdaHide{
\begin{code}
sub-ren ρ ρ′ t = let open Fusion (syntacticFusable SubstitutionRenamingFusable) in lemma t (λ _ _ → PEq.refl)
\end{code}}
\end{corollary}

\begin{corollary}[Substitution-Substitution fusion]Given two substitutitons,
\AB{ρ} from \AB{Γ} to \AB{Δ} and \AB{ρ′} from \AB{Δ} to \AB{Θ}, and a term
\AB{t} of type \AB{σ} with free variables in \AB{Γ}, we have that:\vspace*{ -1.5em}
\AgdaHide{
\begin{code}
SubstitutionFusable :
  SyntacticFusable syntacticSubstitution syntacticSubstitution syntacticSubstitution
  PropEq (λ ρ^A ρ^B ρ^C → ∀ σ pr → subst ρ^B (lookup ρ^A pr) ≡ lookup ρ^C pr)
SubstitutionFusable =
  let module RenSubst = Fusion (syntacticFusable RenamingSubstitutionFusable)
      module SubstRen = Fusion (syntacticFusable SubstitutionRenamingFusable) in
  record { 𝓥^R‿∙   = λ {_} {_} {_} {_} {ρ^A} {ρ^B} {ρ^C} ρ^R eq → [ eq ,, (λ σ pr →
                         PEq.trans (RenSubst.lemma (lookup ρ^A pr) (λ _ _ → PEq.refl))
                                   (ρ^R σ pr)) ]
         ; 𝓥^R‿th  = λ inc {ρ^A} {ρ^B} {ρ^C} ρ^R σ pr →
                         PEq.trans (PEq.sym (SubstRen.lemma (lookup ρ^A pr) (λ _ _ → PEq.refl)))
                                   (PEq.cong (th^Tm σ inc) (ρ^R σ pr))
         ; R⟦var⟧    = λ v ρ^R → ρ^R _ v
         ; var‿0^BC   = PEq.refl }

ifRenNorm :
      {Γ Δ Θ : Cx Ty} {σ : Ty} (b : Tm `2 Γ) (l r : Tm σ Γ)
      {ρ^A : Γ ⊆ Δ} {ρ^B : (Δ -Env) Kr Θ}
      {ρ^C : (Γ -Env) Kr Θ} →
      (ρ^R : (σ : Ty) (pr : Var σ Γ) → PER σ (lookup ρ^B (lookup ρ^A pr)) (lookup ρ^C pr)) →
      Eval.sem Normalise ρ^B (th^Tm `2 ρ^A b) ≡ Eval.sem Normalise ρ^C b →
      PER σ (Eval.sem Normalise ρ^B (th^Tm σ ρ^A l)) (Eval.sem Normalise ρ^C l) →
      PER σ (Eval.sem Normalise ρ^B (th^Tm σ ρ^A r)) (Eval.sem Normalise ρ^C r) →
      PER σ (Eval.sem Normalise ρ^B (th^Tm σ ρ^A (`if b l r))) (Eval.sem Normalise ρ^C (`if b l r))
ifRenNorm b l r {ρ^A} {ρ^B} {ρ^C} ρ^R eqb eql eqr
  with Eval.sem Normalise  ρ^B (th^Tm _ ρ^A b)
     | Eval.sem Normalise ρ^C b
ifRenNorm b l r ρ^R PEq.refl eql eqr | `ne _ t | `ne _ .t =
  reflect^PER _ (PEq.cong₂ (uncurry `if) (PEq.cong₂ _,_ PEq.refl (reify^PER _ eql)) (reify^PER _ eqr))
ifRenNorm b l r ρ^R () eql eqr | `ne _ t | `tt
ifRenNorm b l r ρ^R () eql eqr | `ne _ t | `ff
ifRenNorm b l r ρ^R () eql eqr | `tt | `ne _ t
ifRenNorm b l r ρ^R PEq.refl eql eqr | `tt | `tt = eql
ifRenNorm b l r ρ^R () eql eqr | `tt | `ff
ifRenNorm b l r ρ^R () eql eqr | `ff | `ne _ t
ifRenNorm b l r ρ^R () eql eqr | `ff | `tt
ifRenNorm b l r ρ^R PEq.refl eql eqr | `ff | `ff = eqr
sub-sub : {Γ Δ Θ : Cx Ty} {σ : Ty} (ρ : (Γ -Env) Tm Δ) (ρ′ : (Δ -Env) Tm Θ) (t : Tm σ Γ) → 
\end{code}}
%<*subsub>
\begin{code}
 subst ρ′ (subst ρ t) ≡ subst (map^Env (subst ρ′) ρ) t
\end{code}
%</subsub>
\AgdaHide{
\begin{code}
sub-sub ρ ρ′ t = let open Fusion (syntacticFusable SubstitutionFusable) in lemma t (λ _ _ → PEq.refl)
\end{code}}
\end{corollary}

These four lemmas are usually proven in painful separation. Here
we discharged them by rapid successive instantiation of our framework,
using the earlier results to satisfy the later constraints.
We are not limited to \AR{Syntactic} statements:

\paragraph{Examples of Fusable Semantics}

The most simple example of \AR{Fusable} \AR{Semantics} involving a non
\AR{Syntactic} one is probably the proof that \AR{Renaming} followed
by \AR{Normalise^{βιξη}} is equivalent to NBE with an adjusted environment.

\begin{corollary}[Renaming-Normalise fusion] Given a renaming \AB{ρ}
from \AB{Γ} to \AB{Δ}, an environment of values \AB{ρ′} from \AB{Δ} to
\AB{Θ} such that they are all equal to themselves in the \AF{PER} and
a term \AB{t} of type \AB{σ} with free variables in \AB{Γ}, we have that:\vspace*{ -1.5em}
\AgdaHide{
\begin{code}
RenamingNormaliseFusable : Fusable Renaming Normalise Normalise PER′
  (λ ρ^A ρ^B ρ^C → ∀ σ pr → PER σ (lookup ρ^B (lookup ρ^A pr)) (lookup ρ^C pr)) PER′
RenamingNormaliseFusable =
  record
    { reify^A   = id
    ; 𝓥^R‿∙  = λ ρ^R u^R → [ u^R ,, ρ^R ]
    ; 𝓥^R‿th = λ inc ρ^R → λ σ pr → th^PER σ inc (ρ^R σ pr)
    ; R⟦var⟧   = λ v ρ^R → ρ^R _ v
    ; R⟦$⟧     = λ _ _ r eq _ → r refl eq
    ; R⟦λ⟧     = λ _ r _ inc eq → r inc eq
    ; R⟦⟨⟩⟧    = λ _ → ⟨⟩
    ; R⟦tt⟧    = λ _ → PEq.refl
    ; R⟦ff⟧    = λ _ → PEq.refl
    ; R⟦if⟧  = ifRenNorm
    }

ren-nbe : {Γ Δ Θ : Cx Ty} {σ : Ty} (ρ : Γ ⊆ Δ) (ρ′ : (Δ -Env) Kr Θ) (t : Tm σ Γ) (ρ^R : `∀[ PER′ ] ρ′ ρ′) →
\end{code}}
\begin{code}
 PER σ (nbe ρ′ (th^Tm σ ρ t)) (nbe (select ρ ρ′) t)
\end{code}
\AgdaHide{
\begin{code}
ren-nbe ρ ρ′ t ρ^R = let open Fusion RenamingNormaliseFusable
                     in lemma t (λ σ pr → lookup^R ρ^R (lookup ρ pr))
\end{code}}
\end{corollary}

\AgdaHide{
\begin{code}
ifSubstNorm :
     {Γ Δ Θ : Cx Ty} {σ : Ty} (b : Tm `2 Γ) (l r : Tm σ Γ)
      {ρ^A : (Γ -Env) Tm Δ} {ρ^B : (Δ -Env) Kr Θ}
      {ρ^C : (Γ -Env) Kr Θ} →
      (`∀[ PER′ ] ρ^B ρ^B) ×
      ((σ₁ : Ty) (pr : Var σ₁ Γ) {Θ₁ : Cx Ty} (inc : Θ ⊆ Θ₁) →
       PER σ₁
       (Eval.sem Normalise (pack (λ {σ} → th^Kr σ inc ∘ lookup ρ^B)) (lookup ρ^A pr))
       (th^Kr σ₁ inc (lookup ρ^C pr)))
      ×
      ((σ₁ : Ty) (pr : Var σ₁ Γ) →
       PER σ₁ (Eval.sem Normalise ρ^B (lookup ρ^A  pr)) (lookup ρ^C pr)) →
      Eval.sem Normalise ρ^B (subst ρ^A b) ≡ Eval.sem Normalise ρ^C b →
      PER σ (Eval.sem Normalise ρ^B (subst ρ^A l)) (Eval.sem Normalise ρ^C l) →
      PER σ (Eval.sem Normalise ρ^B (subst ρ^A r)) (Eval.sem Normalise ρ^C r) →
      PER σ (Eval.sem Normalise ρ^B (subst ρ^A (`if b l r))) (Eval.sem Normalise ρ^C (`if b l r))
ifSubstNorm b l r {ρ^A} {ρ^B} {ρ^C} ρ^R eqb eql eqr
  with Eval.sem Normalise ρ^B (subst ρ^A b)
     | Eval.sem Normalise ρ^C b
ifSubstNorm b l r ρ^R PEq.refl eql eqr | `ne _ t | `ne _ .t =
  reflect^PER _ (PEq.cong₂ (uncurry `if) (PEq.cong₂ _,_ PEq.refl (reify^PER _ eql)) (reify^PER _ eqr))
ifSubstNorm b l r ρ^R () eql eqr | `ne _ t | `tt
ifSubstNorm b l r ρ^R () eql eqr | `ne _ t | `ff
ifSubstNorm b l r ρ^R () eql eqr | `tt | `ne _ t
ifSubstNorm b l r ρ^R PEq.refl eql eqr | `tt | `tt = eql
ifSubstNorm b l r ρ^R () eql eqr | `tt | `ff
ifSubstNorm b l r ρ^R () eql eqr | `ff | `ne _ t
ifSubstNorm b l r ρ^R () eql eqr | `ff | `tt
ifSubstNorm b l r ρ^R PEq.refl eql eqr | `ff | `ff = eqr

th-refl : {Γ : Cx Ty} (σ : Ty) {T U : Kr σ Γ} →
          PER σ T U → PER σ (th^Kr σ refl T) U
th-refl `1     eq = ⟨⟩
th-refl `2     eq = PEq.trans (th^nf-refl _) eq
th-refl (σ `→ τ)  eq = eq

th^2 : {Θ Δ Γ : Cx Ty} (σ : Ty) (inc₁ : Γ ⊆ Δ) (inc₂ : Δ ⊆ Θ) {T U : Kr σ Γ} →
       PER σ T U → PER σ (th^Kr σ inc₂ (th^Kr σ inc₁ T)) (th^Kr σ (select inc₁ inc₂) U)
th^2 `1     inc₁ inc₂ eq = ⟨⟩
th^2 `2     inc₁ inc₂ eq = PEq.trans (th^nf-trans inc₁ inc₂ _) (PEq.cong (th^nf `2 (select inc₁ inc₂)) eq)
th^2 (σ `→ τ)  inc₁ inc₂ eq = λ inc₃ → eq (select inc₁ (select inc₂ inc₃))
\end{code}}

Then, we use the framework to prove that to \AR{Normalise^{βιξη}} by
Evaluation after a \AR{Substitution} amounts to normalising the original
term where the substitution has been evaluated first. The constraints
imposed on the environments might seem quite restrictive but they are
actually similar to the Uniformity condition described by C. Coquand~(\citeyear{coquand2002formalised})
in her detailed account of NBE for a ST$λ$C with explicit substitution.


\begin{corollary}[Substitution-Normalise fusion]Given a substitution \AB{ρ}
from \AB{Γ} to \AB{Δ}, an environment of values \AB{ρ′} from \AB{Δ} to \AB{Θ}
such that all these values are equal to themselves and thinning and evaluation
in \AB{ρ′} commute, and a term \AB{t} of type \AB{σ} with free variables in \AB{Γ},
we have that:
\AgdaHide{
\begin{code}
SubstitutionNormaliseFusable : Fusable  Substitution Normalise Normalise
  PER′
  (λ ρ^A ρ^B ρ^C → `∀[ PER′ ] ρ^B ρ^B
                 × ((σ : Ty) (pr : Var σ _) {Θ : Cx Ty} (inc : _ ⊆ Θ) →
                      PER σ (Eval.sem Normalise (pack (λ {σ} pr → th^Kr σ inc (lookup ρ^B pr))) (lookup ρ^A pr)) (th^Kr σ inc (lookup ρ^C pr)))
                 × ((σ : Ty) (pr : Var σ _) → PER σ (Eval.sem Normalise ρ^B (lookup ρ^A pr)) (lookup ρ^C pr)))
  PER′
SubstitutionNormaliseFusable =
  let module RenNorm = Fusion RenamingNormaliseFusable
      module EqNorm  = Simulate SimulationNormalise in
  record
    { reify^A   = id
    ; 𝓥^R‿∙  = λ {_} {_} {_} {_} {ρ^A} {ρ^B} {ρ^C} ρ^R u^R →
                     (proj₁ ρ^R ∙^R refl^PER _ u^R)
                   , [ (λ {Θ} inc → th^PER _ inc u^R)
                     ,, (λ σ pr {Θ} inc →
                       trans^PER σ (RenNorm.lemma (lookup ρ^A pr)
                                                    (λ σ pr → th^PER σ inc (lookup^R (proj₁ ρ^R) pr)))
                                    ((proj₁ ∘ proj₂) ρ^R σ pr inc)) ]
                     , [ u^R ,, (λ σ pr → trans^PER σ (RenNorm.lemma (lookup ρ^A pr) (λ _ → lookup^R (proj₁ ρ^R)))
                                          ((proj₂ ∘ proj₂) ρ^R σ pr)) ]
    ; 𝓥^R‿th = λ inc {ρ^A} ρ^R → pack^R (λ pr → th^PER _ inc (lookup^R (proj₁ ρ^R) pr))
                          , (λ σ pr inc′ →
       trans^PER σ (EqNorm.sim (lookup ρ^A pr) (pack^R (λ {τ} v → trans^PER τ (th^2 τ inc inc′ (lookup^R (proj₁ ρ^R) v)) (th^PER τ (select inc inc′) (lookup^R (proj₁ ρ^R) v)))))
       (trans^PER σ ((proj₁ (proj₂ ρ^R)) σ pr (select inc inc′))
       (sym^PER σ (th^2 σ inc inc′ (refl^PER σ (sym^PER σ (proj₂ (proj₂ ρ^R) σ pr)))))))
                          , (λ σ pr → (proj₁ ∘ proj₂) ρ^R σ pr inc)
    ; R⟦var⟧   = λ v ρ^R → (proj₂ ∘ proj₂) ρ^R _ v
    ; R⟦$⟧     = λ _ _ r eq _ → r refl eq
    ; R⟦λ⟧     = λ _ r _ inc eq → r inc eq
    ; R⟦⟨⟩⟧    = λ _ → ⟨⟩
    ; R⟦tt⟧    = λ _ → PEq.refl
    ; R⟦ff⟧    = λ _ → PEq.refl
    ; R⟦if⟧  = ifSubstNorm
    }

both : {A B : Set} {a₁ a₂ : A} {b₁ b₂ : B} (eq : (A × B F.∋ a₁ , b₁) ≡ (a₂ , b₂)) → a₁ ≡ a₂ × b₁ ≡ b₂
both PEq.refl = PEq.refl , PEq.refl

∷-inj : {A : Set} {a b : A} {as bs : ∞ (Stream A)} (eq : (Stream A F.∋ a ∷ as) ≡ b ∷ bs) → a ≡ b × as ≡ bs
∷-inj PEq.refl = PEq.refl , PEq.refl

sub-nbe : {Γ Δ Θ : Cx Ty} {σ : Ty} (ρ : (Γ -Env) Tm Δ) (ρ′ : (Δ -Env) Kr Θ) (t : Tm σ Γ) (ρ^R : `∀[ PER′ ] ρ′ ρ′) → ∀ ρ^R′ →
\end{code}}
%<*subnbe>
\begin{code}
 PER σ (nbe ρ′ (subst ρ t)) (nbe (map^Env (nbe ρ′) ρ) t)
\end{code}
%</subnbe>
\AgdaHide{
\begin{code}
sub-nbe ρ ρ′ t ρ^R ρ^R′ =
  let open Fusion SubstitutionNormaliseFusable
  in lemma t
     (ρ^R
     , ρ^R′
     , (λ σ pr → let open Simulate SimulationNormalise in sim (lookup ρ pr) ρ^R))
\end{code}}
\end{corollary}


%Finally, we use \AR{Fusable} to prove that our
%definition of pretty-printing ignores \AR{Renamings}. In other
%words, as long as the names provided for the free variables are
%compatible after the renaming and as long as the name supplies
%are equal then the string produced, as well as the state of the
%name supply at the end of the process, are equal.

%\begin{corollary}[Renaming-Printing fusion]
\AgdaHide{
\begin{code}
RenamingPrettyPrintingFusable : Fusable Renaming Printing Printing PropEq
  (λ ρ^A ρ^B → `∀[ PropEq ] (select ρ^A ρ^B))
  (mkRModel (λ p q → ∀ {names₁ names₂} → names₁ ≡ names₂ → runP p names₁ ≡ runP q names₂))
RenamingPrettyPrintingFusable = record
  { reify^A   = id
  ; 𝓥^R‿∙   = λ {Γ} {Δ} {Θ} {σ} {ρ^A} {ρ^B} {ρ^C} {u^B} {u^C} ρ^R eq → pack^R ((λ {σ} v → [_,,_] {P = λ σ v → lookup (select (step ρ^A `∙ ze) (ρ^B `∙ u^B)) v ≡ lookup (ρ^C `∙ u^C) v} eq (λ σ v → lookup^R ρ^R v) σ v))
  ; 𝓥^R‿th  = λ _ ρ^R → pack^R (PEq.cong (mkN ∘ getN) ∘ lookup^R ρ^R)
  ; R⟦var⟧   = λ v ρ^R → PEq.cong₂ (λ n ns → getN n , ns) (lookup^R ρ^R v)
  ; R⟦λ⟧     = λ t r ρ^R → λ { {n₁ ∷ n₁s} {n₂ ∷ n₂s} eq →
                        let (neq   , nseq) = ∷-inj eq
                            (ihstr , ihns) = both (r (step refl) (PEq.cong mkN neq) (PEq.cong ♭ nseq))
                        in PEq.cong₂ _,_ (PEq.cong₂ (λ n str → "λ" ++ n ++ ". " ++ str) neq ihstr) ihns }
  ; R⟦$⟧     = λ f t {ρ^A} {ρ^B} {ρ^C} ihf iht ρ^R eq →
                        let (ihstrf , eq₁) = both (ihf eq)
                            (ihstrt , eq₂) = both (iht eq₁)
                        in PEq.cong₂ _,_ (PEq.cong₂ (λ strf strt → strf ++ " (" ++ strt ++ ")") ihstrf ihstrt) eq₂
  ; R⟦⟨⟩⟧    = λ _ → PEq.cong _
  ; R⟦tt⟧    = λ _ → PEq.cong _
  ; R⟦ff⟧    = λ _ → PEq.cong _
  ; R⟦if⟧    = λ b l r {ρ^A} {ρ^B} {ρ^C} ρ^R ihb ihl ihr eq →
                       let (ihstrb , eq₁) = both (ihb eq)
                           (ihstrl , eq₂) = both (ihl eq₁)
                           (ihstrr , eq₃) = both (ihr eq₂)
                       in PEq.cong₂ _,_ (PEq.cong₂ (λ strb strlr → "if (" ++ strb ++ ") then (" ++ strlr)
                                        ihstrb (PEq.cong₂ (λ strl strr → strl ++ ") else (" ++ strr ++ ")")
                                        ihstrl ihstrr)) eq₃ }

tailComm : (Δ Γ : Cx Ty) {names : Stream String} →
           tail (proj₂ (nameContext Δ Γ names)) ≡ proj₂ (nameContext Δ Γ (tail names))
tailComm Δ ε        = PEq.refl
tailComm Δ (Γ ∙ _)  = PEq.cong tail (tailComm Δ Γ)

proof : (Δ Γ : Cx Ty) {names : Stream String} → proj₂ (nameContext Δ Γ names) ≡ Stream.drop (size Γ) names
proof Δ ε                = PEq.refl
proof Δ (Γ ∙ x) {n ∷ ns} = PEq.trans (tailComm Δ Γ) (proof Δ Γ)

ren-print : {Γ : Cx Ty} {σ : Ty} (t : Tm σ ε) (inc : ε ⊆ Γ) →
\end{code}
\begin{code}
 print (th^Tm σ inc t) ≡ proj₁ (runP (Eval.sem Printing `ε t) (Stream.drop (size Γ) names))
\end{code}
\begin{code}
ren-print {Γ} t inc = PEq.cong proj₁ (lemma t (pack^R (λ ())) (proof Γ Γ))
  where open Fusion RenamingPrettyPrintingFusable
\end{code}}
%\end{corollary}