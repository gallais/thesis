\paragraph{The Special Case of Syntactic Semantics}

The translation from \AR{Syntactic} to \AR{Semantics} uses a lot
of constructors as their own semantic counterpart, it is hence possible to generate
evidence of \AR{Syntactic} triplets being fusable with much fewer assumptions.
We isolate them and prove the result generically to avoid repetition. A
\AR{SyntacticFusable} record packs the evidence for
\AR{Syntactic} semantics \AB{syn^A}, \AB{syn^B} and \AB{syn^C}. It is indexed
by these three \AR{Syntactic}s as well as two relations corresponding to the
\AB{ğ“¥^R_{BC}} and \AB{ğ“¥^R} ones of the \AR{Fusable} framework.
It contains the same \ARF{ğ“¥^Râ€¿âˆ™}, \ARF{ğ“¥^Râ€¿th} and \ARF{RâŸ¦varâŸ§}
fields as a \AR{Fusable} as well as a fourth one (\ARF{varâ€¿0^{BC}})
saying that \AB{syn^B} and \AB{syn^C}'s respective \ARF{varâ€¿0}s are
producing related values.
\AgdaHide{
\begin{code}
record SyntacticFusable
  {â„“^EA â„“^EB â„“^EC â„“^REBC â„“^RE : Level} {ğ“¥^A : Model â„“^EA} {ğ“¥^B : Model â„“^EB} {ğ“¥^C : Model â„“^EC} (synA : Syntactic ğ“¥^A)
  (synB : Syntactic ğ“¥^B)
  (synC : Syntactic ğ“¥^C)
  (ğ“¥^Râ€¿BC : RModel ğ“¥^B ğ“¥^C â„“^REBC)
  (ğ“¥^R : {Î˜ Î” Î“ : Cx Ty} (Ï^A : (Î“ -Env) ğ“¥^A Î”) (Ï^B : (Î” -Env) ğ“¥^B Î˜) (Ï^C : (Î“ -Env) ğ“¥^C Î˜) â†’ Set â„“^RE)
  : Set (â„“^RE âŠ” â„“^REBC âŠ” â„“^EC âŠ” â„“^EB âŠ” â„“^EA)
  where
  module Syn^A = Syntactic synA
  module Syn^B = Syntactic synB
  module Syn^C = Syntactic synC
  field
    ğ“¥^Râ€¿âˆ™ : ({Î“ Î” Î˜ : Cx Ty} {Ïƒ : Ty} {Ï^A : (Î“ -Env) ğ“¥^A Î”} {Ï^B : (Î” -Env) ğ“¥^B Î˜} {Ï^C : (Î“ -Env) ğ“¥^C Î˜}
               {u^B : ğ“¥^B Ïƒ Î˜} {u^C : ğ“¥^C Ïƒ Î˜} (Ï^R : ğ“¥^R Ï^A Ï^B Ï^C) (u^R : rmodel ğ“¥^Râ€¿BC u^B u^C) â†’
               ğ“¥^R (th[ Syn^A.th ] (step refl) Ï^A `âˆ™ Syn^A.varâ€¿0)
                      (Ï^B `âˆ™ u^B)
                      (Ï^C `âˆ™ u^C))
    ğ“¥^Râ€¿th : {Î“ Î” Î˜ E : Cx Ty} (inc : Î˜ âŠ† E)
               {Ï^A : (Î“ -Env) ğ“¥^A Î”} {Ï^B : (Î” -Env) ğ“¥^B Î˜} {Ï^C : (Î“ -Env) ğ“¥^C Î˜} (Ï^R : ğ“¥^R Ï^A Ï^B Ï^C) â†’
               ğ“¥^R Ï^A(th[ Syn^B.th ] inc Ï^B) (th[ Syn^C.th ] inc Ï^C)
    RâŸ¦varâŸ§  : {Î“ Î” Î˜ : Cx Ty} {Ïƒ : Ty} {Ï^A : (Î“ -Env) ğ“¥^A Î”} {Ï^B : (Î” -Env) ğ“¥^B Î˜} {Ï^C : (Î“ -Env) ğ“¥^C Î˜}
              â†’ (v : Var Ïƒ Î“) â†’ ğ“¥^R Ï^A Ï^B Ï^C â†’
              Eval.sem (syntactic synB) Ï^B (Eval.sem (syntactic synA) Ï^A (`var v))
              â‰¡ Eval.sem (syntactic synC) Ï^C (`var v)
\end{code}}
\begin{code}
    varâ€¿0^BC : {Î“ : Cx Ty} {Ïƒ : Ty} â†’ rmodel ğ“¥^Râ€¿BC {Ïƒ} {Î“ âˆ™ Ïƒ} Syn^B.varâ€¿0 Syn^C.varâ€¿0
\end{code}

\begin{theorem}[Fundamental Lemma of Fusable Syntactics]
Given a \AR{SyntacticFusable} relating three \AR{Syntactic} semantics,
we get a \AR{Fusable} relating the corresponding \AR{Semantics} where
\AB{ğ“’^R} is the propositional equality.
\end{theorem}
\begin{proof}The proof relies on the way the translation from \AR{Syntactic}
to \AR{Semantics} is formulated in \cref{syntactic}.
\end{proof}
\AgdaHide{
\begin{code}
syntacticFusable :  {â„“^EA â„“^EB â„“^EC â„“^RE â„“^REBC : Level} {ğ“¥^A : Model â„“^EA} {ğ“¥^B : Model â„“^EB} {ğ“¥^C : Model â„“^EC} {syn^A : Syntactic ğ“¥^A} {syn^B : Syntactic ğ“¥^B} {syn^C : Syntactic ğ“¥^C} {ğ“¥^Râ€¿BC : RModel ğ“¥^B ğ“¥^C â„“^REBC} {ğ“¥^R : {Î˜ Î” Î“ : Cx Ty} (Ï^A : (Î“ -Env) ğ“¥^A Î”) (Ï^B : (Î” -Env) ğ“¥^B Î˜) (Ï^C : (Î“ -Env) ğ“¥^C Î˜) â†’ Set â„“^RE} (syn^R : SyntacticFusable syn^A syn^B syn^C ğ“¥^Râ€¿BC ğ“¥^R) â†’
  Fusable (syntactic syn^A) (syntactic syn^B) (syntactic syn^C) ğ“¥^Râ€¿BC ğ“¥^R PropEq
syntacticFusable synF =
  let open SyntacticFusable synF in
  record
    { reify^A    = id
    ; ğ“¥^Râ€¿âˆ™   = ğ“¥^Râ€¿âˆ™
    ; ğ“¥^Râ€¿th  = ğ“¥^Râ€¿th
    ; RâŸ¦varâŸ§    = RâŸ¦varâŸ§
    ; RâŸ¦$âŸ§      = Î» f t eqf eqt Ï^R â†’ PEq.congâ‚‚ _`$_ eqf eqt
    ; RâŸ¦Î»âŸ§      = Î» t r Ï^R â†’ PEq.cong `Î» (r (step refl) varâ€¿0^BC)
    ; RâŸ¦âŸ¨âŸ©âŸ§     = Î» Ï^R â†’ PEq.refl
    ; RâŸ¦ttâŸ§     = Î» Ï^R â†’ PEq.refl
    ; RâŸ¦ffâŸ§     = Î» Ï^R â†’ PEq.refl
    ; RâŸ¦ifâŸ§   = Î» b l r Ï^R eqb eql â†’ PEq.congâ‚‚ (uncurry `if) (PEq.congâ‚‚ _,_ eqb eql)
    }

`var-inj : {Î“ : Cx Ty} {Ïƒ : Ty} {prâ‚ prâ‚‚ : Var Ïƒ Î“} (eq : (Tm Ïƒ Î“ F.âˆ‹ `var prâ‚) â‰¡ `var prâ‚‚) â†’ prâ‚ â‰¡ prâ‚‚
`var-inj PEq.refl = PEq.refl
\end{code}}

\begin{corollary}[Renaming-Renaming fusion]Given two renamings \AB{Ï} from
\AB{Î“} to \AB{Î”} and \AB{Ïâ€²} from \AB{Î”} to \AB{Î˜} and a term \AB{t} of type
\AB{Ïƒ} with free variables in \AB{Î“}, we have that:
\AgdaHide{
\begin{code}
RenamingFusable :
  SyntacticFusable  syntacticRenaming syntacticRenaming syntacticRenaming
                    PropEq (Î» Ï^A Ï^B Ï^C â†’ âˆ€ Ïƒ pr â†’ lookup (select Ï^A Ï^B) pr â‰¡ lookup Ï^C pr)
RenamingFusable = record
  { ğ“¥^Râ€¿âˆ™     = Î» Ï^R eq â†’ [ eq ,, Ï^R ]
  ; ğ“¥^Râ€¿th    = Î» inc Ï^R Ïƒ pr â†’ PEq.cong (lookup inc) (Ï^R Ïƒ pr)
  ; RâŸ¦varâŸ§    = Î» v Ï^R â†’ PEq.cong `var (Ï^R _ v)
  ; varâ€¿0^BC  = PEq.refl }

ren-ren : {Î“ Î” Î˜ : Cx Ty} {Ïƒ : Ty} (Ï : Î“ âŠ† Î”) (Ïâ€² : Î” âŠ† Î˜) (t : Tm Ïƒ Î“) â†’ 
\end{code}}
%<*renren>
\begin{code}
 th^Tm Ïƒ Ïâ€² (th^Tm Ïƒ Ï t) â‰¡ th^Tm Ïƒ (Ïâ€² [âˆ˜] Ï) t
\end{code}
%</renren>
\AgdaHide{
\begin{code}
ren-ren Ï Ïâ€² t = let open Fusion (syntacticFusable RenamingFusable) in lemma t (Î» _ _ â†’ PEq.refl)
\end{code}}
\end{corollary}

\begin{corollary}[Renaming-Substitution fusion]Given a renaming \AB{Ï} from
\AB{Î“} to \AB{Î”}, a substitution \AB{Ïâ€²} from \AB{Î”} to \AB{Î˜} and a term
\AB{t} of type \AB{Ïƒ} with free variables in \AB{Î“}, we have that:\vspace*{ -1.5em}
\AgdaHide{
\begin{code}
RenamingSubstitutionFusable :
  SyntacticFusable syntacticRenaming syntacticSubstitution syntacticSubstitution
  PropEq (Î» Ï^A Ï^B Ï^C â†’ âˆ€ Ïƒ pr â†’ lookup Ï^B (lookup Ï^A pr) â‰¡ lookup Ï^C pr)
RenamingSubstitutionFusable = record
  { ğ“¥^Râ€¿âˆ™   = Î» Ï^R eq â†’ [ eq ,, Ï^R ]
  ; ğ“¥^Râ€¿th  = Î» inc Ï^R Ïƒ pr â†’ PEq.cong (th^Tm Ïƒ inc) (Ï^R Ïƒ pr)
  ; RâŸ¦varâŸ§    = Î» v Ï^R â†’ Ï^R _ v
  ; varâ€¿0^BC   = PEq.refl }

ren-sub : {Î“ Î” Î˜ : Cx Ty} {Ïƒ : Ty} (Ï : Î“ âŠ† Î”) (Ïâ€² : (Î” -Env) Tm Î˜) (t : Tm Ïƒ Î“) â†’ 
\end{code}}
%<*rensub>
\begin{code}
 subst Ïâ€² (th^Tm Ïƒ Ï t) â‰¡ subst (Ïâ€² [âˆ˜] Ï) t
\end{code}
%</rensub>
\AgdaHide{
\begin{code}
ren-sub Ï Ïâ€² t = let open Fusion (syntacticFusable RenamingSubstitutionFusable) in lemma t (Î» _ _ â†’ PEq.refl)
\end{code}}
\end{corollary}

\begin{corollary}[Substitution-Renaming fusion]Given a substitution \AB{Ï}
from \AB{Î“} to \AB{Î”}, a renaming \AB{Ïâ€²} from \AB{Î”} to \AB{Î˜} and a term
\AB{t} of type \AB{Ïƒ} with free variables in \AB{Î“}, we have that:\vspace*{ -1.5em}
\AgdaHide{
\begin{code}
SubstitutionRenamingFusable :
  SyntacticFusable syntacticSubstitution syntacticRenaming syntacticSubstitution
  (mkRModel (_â‰¡_ âˆ˜ `var)) (Î» Ï^A Ï^B Ï^C â†’ âˆ€ Ïƒ pr â†’ th^Tm Ïƒ Ï^B (lookup Ï^A pr) â‰¡ lookup Ï^C pr)
SubstitutionRenamingFusable =
  let module RenRen = Fusion (syntacticFusable RenamingFusable) in
  record { ğ“¥^Râ€¿âˆ™   = Î» {_} {_} {_} {_} {Ï^A} {Ï^B} {Ï^C} Ï^R eq â†’ [ eq ,, (Î» Ïƒ pr â†’
                         PEq.trans (RenRen.lemma (lookup Ï^A pr) (Î» _ _ â†’ PEq.refl))
                                   (Ï^R Ïƒ pr)) ]
         ; ğ“¥^Râ€¿th  = Î» inc {Ï^A} {Ï^B} {Ï^C} Ï^R Ïƒ pr â†’
                         PEq.trans (PEq.sym (RenRen.lemma (lookup Ï^A pr) (Î» _ _ â†’ PEq.refl)))
                                   (PEq.cong (th^Tm Ïƒ inc) (Ï^R Ïƒ pr))
         ; RâŸ¦varâŸ§    = Î» v Ï^R â†’ Ï^R _ v
         ; varâ€¿0^BC   = PEq.refl }
sub-ren : {Î“ Î” Î˜ : Cx Ty} {Ïƒ : Ty} (Ï : (Î“ -Env) Tm Î”) (Ïâ€² : Î” âŠ† Î˜) (t : Tm Ïƒ Î“) â†’ 
\end{code}}
%<*subren>
\begin{code}
 th^Tm Ïƒ Ïâ€² (subst Ï t) â‰¡ subst (map^Env (th^Tm _ Ïâ€²) Ï) t
\end{code}
%</subren>
\AgdaHide{
\begin{code}
sub-ren Ï Ïâ€² t = let open Fusion (syntacticFusable SubstitutionRenamingFusable) in lemma t (Î» _ _ â†’ PEq.refl)
\end{code}}
\end{corollary}

\begin{corollary}[Substitution-Substitution fusion]Given two substitutitons,
\AB{Ï} from \AB{Î“} to \AB{Î”} and \AB{Ïâ€²} from \AB{Î”} to \AB{Î˜}, and a term
\AB{t} of type \AB{Ïƒ} with free variables in \AB{Î“}, we have that:\vspace*{ -1.5em}
\AgdaHide{
\begin{code}
SubstitutionFusable :
  SyntacticFusable syntacticSubstitution syntacticSubstitution syntacticSubstitution
  PropEq (Î» Ï^A Ï^B Ï^C â†’ âˆ€ Ïƒ pr â†’ subst Ï^B (lookup Ï^A pr) â‰¡ lookup Ï^C pr)
SubstitutionFusable =
  let module RenSubst = Fusion (syntacticFusable RenamingSubstitutionFusable)
      module SubstRen = Fusion (syntacticFusable SubstitutionRenamingFusable) in
  record { ğ“¥^Râ€¿âˆ™   = Î» {_} {_} {_} {_} {Ï^A} {Ï^B} {Ï^C} Ï^R eq â†’ [ eq ,, (Î» Ïƒ pr â†’
                         PEq.trans (RenSubst.lemma (lookup Ï^A pr) (Î» _ _ â†’ PEq.refl))
                                   (Ï^R Ïƒ pr)) ]
         ; ğ“¥^Râ€¿th  = Î» inc {Ï^A} {Ï^B} {Ï^C} Ï^R Ïƒ pr â†’
                         PEq.trans (PEq.sym (SubstRen.lemma (lookup Ï^A pr) (Î» _ _ â†’ PEq.refl)))
                                   (PEq.cong (th^Tm Ïƒ inc) (Ï^R Ïƒ pr))
         ; RâŸ¦varâŸ§    = Î» v Ï^R â†’ Ï^R _ v
         ; varâ€¿0^BC   = PEq.refl }

ifRenNorm :
      {Î“ Î” Î˜ : Cx Ty} {Ïƒ : Ty} (b : Tm `2 Î“) (l r : Tm Ïƒ Î“)
      {Ï^A : Î“ âŠ† Î”} {Ï^B : (Î” -Env) Kr Î˜}
      {Ï^C : (Î“ -Env) Kr Î˜} â†’
      (Ï^R : (Ïƒ : Ty) (pr : Var Ïƒ Î“) â†’ PER Ïƒ (lookup Ï^B (lookup Ï^A pr)) (lookup Ï^C pr)) â†’
      Eval.sem Normalise Ï^B (th^Tm `2 Ï^A b) â‰¡ Eval.sem Normalise Ï^C b â†’
      PER Ïƒ (Eval.sem Normalise Ï^B (th^Tm Ïƒ Ï^A l)) (Eval.sem Normalise Ï^C l) â†’
      PER Ïƒ (Eval.sem Normalise Ï^B (th^Tm Ïƒ Ï^A r)) (Eval.sem Normalise Ï^C r) â†’
      PER Ïƒ (Eval.sem Normalise Ï^B (th^Tm Ïƒ Ï^A (`if b l r))) (Eval.sem Normalise Ï^C (`if b l r))
ifRenNorm b l r {Ï^A} {Ï^B} {Ï^C} Ï^R eqb eql eqr
  with Eval.sem Normalise  Ï^B (th^Tm _ Ï^A b)
     | Eval.sem Normalise Ï^C b
ifRenNorm b l r Ï^R PEq.refl eql eqr | `ne _ t | `ne _ .t =
  reflect^PER _ (PEq.congâ‚‚ (uncurry `if) (PEq.congâ‚‚ _,_ PEq.refl (reify^PER _ eql)) (reify^PER _ eqr))
ifRenNorm b l r Ï^R () eql eqr | `ne _ t | `tt
ifRenNorm b l r Ï^R () eql eqr | `ne _ t | `ff
ifRenNorm b l r Ï^R () eql eqr | `tt | `ne _ t
ifRenNorm b l r Ï^R PEq.refl eql eqr | `tt | `tt = eql
ifRenNorm b l r Ï^R () eql eqr | `tt | `ff
ifRenNorm b l r Ï^R () eql eqr | `ff | `ne _ t
ifRenNorm b l r Ï^R () eql eqr | `ff | `tt
ifRenNorm b l r Ï^R PEq.refl eql eqr | `ff | `ff = eqr
sub-sub : {Î“ Î” Î˜ : Cx Ty} {Ïƒ : Ty} (Ï : (Î“ -Env) Tm Î”) (Ïâ€² : (Î” -Env) Tm Î˜) (t : Tm Ïƒ Î“) â†’ 
\end{code}}
%<*subsub>
\begin{code}
 subst Ïâ€² (subst Ï t) â‰¡ subst (map^Env (subst Ïâ€²) Ï) t
\end{code}
%</subsub>
\AgdaHide{
\begin{code}
sub-sub Ï Ïâ€² t = let open Fusion (syntacticFusable SubstitutionFusable) in lemma t (Î» _ _ â†’ PEq.refl)
\end{code}}
\end{corollary}

These four lemmas are usually proven in painful separation. Here
we discharged them by rapid successive instantiation of our framework,
using the earlier results to satisfy the later constraints.
We are not limited to \AR{Syntactic} statements:

\paragraph{Examples of Fusable Semantics}

The most simple example of \AR{Fusable} \AR{Semantics} involving a non
\AR{Syntactic} one is probably the proof that \AR{Renaming} followed
by \AR{Normalise^{Î²Î¹Î¾Î·}} is equivalent to NBE with an adjusted environment.

\begin{corollary}[Renaming-Normalise fusion] Given a renaming \AB{Ï}
from \AB{Î“} to \AB{Î”}, an environment of values \AB{Ïâ€²} from \AB{Î”} to
\AB{Î˜} such that they are all equal to themselves in the \AF{PER} and
a term \AB{t} of type \AB{Ïƒ} with free variables in \AB{Î“}, we have that:\vspace*{ -1.5em}
\AgdaHide{
\begin{code}
RenamingNormaliseFusable : Fusable Renaming Normalise Normalise PERâ€²
  (Î» Ï^A Ï^B Ï^C â†’ âˆ€ Ïƒ pr â†’ PER Ïƒ (lookup Ï^B (lookup Ï^A pr)) (lookup Ï^C pr)) PERâ€²
RenamingNormaliseFusable =
  record
    { reify^A   = id
    ; ğ“¥^Râ€¿âˆ™  = Î» Ï^R u^R â†’ [ u^R ,, Ï^R ]
    ; ğ“¥^Râ€¿th = Î» inc Ï^R â†’ Î» Ïƒ pr â†’ th^PER Ïƒ inc (Ï^R Ïƒ pr)
    ; RâŸ¦varâŸ§   = Î» v Ï^R â†’ Ï^R _ v
    ; RâŸ¦$âŸ§     = Î» _ _ r eq _ â†’ r refl eq
    ; RâŸ¦Î»âŸ§     = Î» _ r _ inc eq â†’ r inc eq
    ; RâŸ¦âŸ¨âŸ©âŸ§    = Î» _ â†’ âŸ¨âŸ©
    ; RâŸ¦ttâŸ§    = Î» _ â†’ PEq.refl
    ; RâŸ¦ffâŸ§    = Î» _ â†’ PEq.refl
    ; RâŸ¦ifâŸ§  = ifRenNorm
    }

ren-nbe : {Î“ Î” Î˜ : Cx Ty} {Ïƒ : Ty} (Ï : Î“ âŠ† Î”) (Ïâ€² : (Î” -Env) Kr Î˜) (t : Tm Ïƒ Î“) (Ï^R : `âˆ€[ PERâ€² ] Ïâ€² Ïâ€²) â†’
\end{code}}
\begin{code}
 PER Ïƒ (nbe Ïâ€² (th^Tm Ïƒ Ï t)) (nbe (select Ï Ïâ€²) t)
\end{code}
\AgdaHide{
\begin{code}
ren-nbe Ï Ïâ€² t Ï^R = let open Fusion RenamingNormaliseFusable
                     in lemma t (Î» Ïƒ pr â†’ lookup^R Ï^R (lookup Ï pr))
\end{code}}
\end{corollary}

\AgdaHide{
\begin{code}
ifSubstNorm :
     {Î“ Î” Î˜ : Cx Ty} {Ïƒ : Ty} (b : Tm `2 Î“) (l r : Tm Ïƒ Î“)
      {Ï^A : (Î“ -Env) Tm Î”} {Ï^B : (Î” -Env) Kr Î˜}
      {Ï^C : (Î“ -Env) Kr Î˜} â†’
      (`âˆ€[ PERâ€² ] Ï^B Ï^B) Ã—
      ((Ïƒâ‚ : Ty) (pr : Var Ïƒâ‚ Î“) {Î˜â‚ : Cx Ty} (inc : Î˜ âŠ† Î˜â‚) â†’
       PER Ïƒâ‚
       (Eval.sem Normalise (pack (Î» {Ïƒ} â†’ th^Kr Ïƒ inc âˆ˜ lookup Ï^B)) (lookup Ï^A pr))
       (th^Kr Ïƒâ‚ inc (lookup Ï^C pr)))
      Ã—
      ((Ïƒâ‚ : Ty) (pr : Var Ïƒâ‚ Î“) â†’
       PER Ïƒâ‚ (Eval.sem Normalise Ï^B (lookup Ï^A  pr)) (lookup Ï^C pr)) â†’
      Eval.sem Normalise Ï^B (subst Ï^A b) â‰¡ Eval.sem Normalise Ï^C b â†’
      PER Ïƒ (Eval.sem Normalise Ï^B (subst Ï^A l)) (Eval.sem Normalise Ï^C l) â†’
      PER Ïƒ (Eval.sem Normalise Ï^B (subst Ï^A r)) (Eval.sem Normalise Ï^C r) â†’
      PER Ïƒ (Eval.sem Normalise Ï^B (subst Ï^A (`if b l r))) (Eval.sem Normalise Ï^C (`if b l r))
ifSubstNorm b l r {Ï^A} {Ï^B} {Ï^C} Ï^R eqb eql eqr
  with Eval.sem Normalise Ï^B (subst Ï^A b)
     | Eval.sem Normalise Ï^C b
ifSubstNorm b l r Ï^R PEq.refl eql eqr | `ne _ t | `ne _ .t =
  reflect^PER _ (PEq.congâ‚‚ (uncurry `if) (PEq.congâ‚‚ _,_ PEq.refl (reify^PER _ eql)) (reify^PER _ eqr))
ifSubstNorm b l r Ï^R () eql eqr | `ne _ t | `tt
ifSubstNorm b l r Ï^R () eql eqr | `ne _ t | `ff
ifSubstNorm b l r Ï^R () eql eqr | `tt | `ne _ t
ifSubstNorm b l r Ï^R PEq.refl eql eqr | `tt | `tt = eql
ifSubstNorm b l r Ï^R () eql eqr | `tt | `ff
ifSubstNorm b l r Ï^R () eql eqr | `ff | `ne _ t
ifSubstNorm b l r Ï^R () eql eqr | `ff | `tt
ifSubstNorm b l r Ï^R PEq.refl eql eqr | `ff | `ff = eqr

th-refl : {Î“ : Cx Ty} (Ïƒ : Ty) {T U : Kr Ïƒ Î“} â†’
          PER Ïƒ T U â†’ PER Ïƒ (th^Kr Ïƒ refl T) U
th-refl `1     eq = âŸ¨âŸ©
th-refl `2     eq = PEq.trans (th^nf-refl _) eq
th-refl (Ïƒ `â†’ Ï„)  eq = eq

th^2 : {Î˜ Î” Î“ : Cx Ty} (Ïƒ : Ty) (incâ‚ : Î“ âŠ† Î”) (incâ‚‚ : Î” âŠ† Î˜) {T U : Kr Ïƒ Î“} â†’
       PER Ïƒ T U â†’ PER Ïƒ (th^Kr Ïƒ incâ‚‚ (th^Kr Ïƒ incâ‚ T)) (th^Kr Ïƒ (select incâ‚ incâ‚‚) U)
th^2 `1     incâ‚ incâ‚‚ eq = âŸ¨âŸ©
th^2 `2     incâ‚ incâ‚‚ eq = PEq.trans (th^nf-trans incâ‚ incâ‚‚ _) (PEq.cong (th^nf `2 (select incâ‚ incâ‚‚)) eq)
th^2 (Ïƒ `â†’ Ï„)  incâ‚ incâ‚‚ eq = Î» incâ‚ƒ â†’ eq (select incâ‚ (select incâ‚‚ incâ‚ƒ))
\end{code}}

Then, we use the framework to prove that to \AR{Normalise^{Î²Î¹Î¾Î·}} by
Evaluation after a \AR{Substitution} amounts to normalising the original
term where the substitution has been evaluated first. The constraints
imposed on the environments might seem quite restrictive but they are
actually similar to the Uniformity condition described by C. Coquand~(\citeyear{coquand2002formalised})
in her detailed account of NBE for a ST$Î»$C with explicit substitution.


\begin{corollary}[Substitution-Normalise fusion]Given a substitution \AB{Ï}
from \AB{Î“} to \AB{Î”}, an environment of values \AB{Ïâ€²} from \AB{Î”} to \AB{Î˜}
such that all these values are equal to themselves and thinning and evaluation
in \AB{Ïâ€²} commute, and a term \AB{t} of type \AB{Ïƒ} with free variables in \AB{Î“},
we have that:
\AgdaHide{
\begin{code}
SubstitutionNormaliseFusable : Fusable  Substitution Normalise Normalise
  PERâ€²
  (Î» Ï^A Ï^B Ï^C â†’ `âˆ€[ PERâ€² ] Ï^B Ï^B
                 Ã— ((Ïƒ : Ty) (pr : Var Ïƒ _) {Î˜ : Cx Ty} (inc : _ âŠ† Î˜) â†’
                      PER Ïƒ (Eval.sem Normalise (pack (Î» {Ïƒ} pr â†’ th^Kr Ïƒ inc (lookup Ï^B pr))) (lookup Ï^A pr)) (th^Kr Ïƒ inc (lookup Ï^C pr)))
                 Ã— ((Ïƒ : Ty) (pr : Var Ïƒ _) â†’ PER Ïƒ (Eval.sem Normalise Ï^B (lookup Ï^A pr)) (lookup Ï^C pr)))
  PERâ€²
SubstitutionNormaliseFusable =
  let module RenNorm = Fusion RenamingNormaliseFusable
      module EqNorm  = Simulate SimulationNormalise in
  record
    { reify^A   = id
    ; ğ“¥^Râ€¿âˆ™  = Î» {_} {_} {_} {_} {Ï^A} {Ï^B} {Ï^C} Ï^R u^R â†’
                     (projâ‚ Ï^R âˆ™^R refl^PER _ u^R)
                   , [ (Î» {Î˜} inc â†’ th^PER _ inc u^R)
                     ,, (Î» Ïƒ pr {Î˜} inc â†’
                       trans^PER Ïƒ (RenNorm.lemma (lookup Ï^A pr)
                                                    (Î» Ïƒ pr â†’ th^PER Ïƒ inc (lookup^R (projâ‚ Ï^R) pr)))
                                    ((projâ‚ âˆ˜ projâ‚‚) Ï^R Ïƒ pr inc)) ]
                     , [ u^R ,, (Î» Ïƒ pr â†’ trans^PER Ïƒ (RenNorm.lemma (lookup Ï^A pr) (Î» _ â†’ lookup^R (projâ‚ Ï^R)))
                                          ((projâ‚‚ âˆ˜ projâ‚‚) Ï^R Ïƒ pr)) ]
    ; ğ“¥^Râ€¿th = Î» inc {Ï^A} Ï^R â†’ pack^R (Î» pr â†’ th^PER _ inc (lookup^R (projâ‚ Ï^R) pr))
                          , (Î» Ïƒ pr incâ€² â†’
       trans^PER Ïƒ (EqNorm.sim (lookup Ï^A pr) (pack^R (Î» {Ï„} v â†’ trans^PER Ï„ (th^2 Ï„ inc incâ€² (lookup^R (projâ‚ Ï^R) v)) (th^PER Ï„ (select inc incâ€²) (lookup^R (projâ‚ Ï^R) v)))))
       (trans^PER Ïƒ ((projâ‚ (projâ‚‚ Ï^R)) Ïƒ pr (select inc incâ€²))
       (sym^PER Ïƒ (th^2 Ïƒ inc incâ€² (refl^PER Ïƒ (sym^PER Ïƒ (projâ‚‚ (projâ‚‚ Ï^R) Ïƒ pr)))))))
                          , (Î» Ïƒ pr â†’ (projâ‚ âˆ˜ projâ‚‚) Ï^R Ïƒ pr inc)
    ; RâŸ¦varâŸ§   = Î» v Ï^R â†’ (projâ‚‚ âˆ˜ projâ‚‚) Ï^R _ v
    ; RâŸ¦$âŸ§     = Î» _ _ r eq _ â†’ r refl eq
    ; RâŸ¦Î»âŸ§     = Î» _ r _ inc eq â†’ r inc eq
    ; RâŸ¦âŸ¨âŸ©âŸ§    = Î» _ â†’ âŸ¨âŸ©
    ; RâŸ¦ttâŸ§    = Î» _ â†’ PEq.refl
    ; RâŸ¦ffâŸ§    = Î» _ â†’ PEq.refl
    ; RâŸ¦ifâŸ§  = ifSubstNorm
    }

both : {A B : Set} {aâ‚ aâ‚‚ : A} {bâ‚ bâ‚‚ : B} (eq : (A Ã— B F.âˆ‹ aâ‚ , bâ‚) â‰¡ (aâ‚‚ , bâ‚‚)) â†’ aâ‚ â‰¡ aâ‚‚ Ã— bâ‚ â‰¡ bâ‚‚
both PEq.refl = PEq.refl , PEq.refl

âˆ·-inj : {A : Set} {a b : A} {as bs : âˆ (Stream A)} (eq : (Stream A F.âˆ‹ a âˆ· as) â‰¡ b âˆ· bs) â†’ a â‰¡ b Ã— as â‰¡ bs
âˆ·-inj PEq.refl = PEq.refl , PEq.refl

sub-nbe : {Î“ Î” Î˜ : Cx Ty} {Ïƒ : Ty} (Ï : (Î“ -Env) Tm Î”) (Ïâ€² : (Î” -Env) Kr Î˜) (t : Tm Ïƒ Î“) (Ï^R : `âˆ€[ PERâ€² ] Ïâ€² Ïâ€²) â†’ âˆ€ Ï^Râ€² â†’
\end{code}}
%<*subnbe>
\begin{code}
 PER Ïƒ (nbe Ïâ€² (subst Ï t)) (nbe (map^Env (nbe Ïâ€²) Ï) t)
\end{code}
%</subnbe>
\AgdaHide{
\begin{code}
sub-nbe Ï Ïâ€² t Ï^R Ï^Râ€² =
  let open Fusion SubstitutionNormaliseFusable
  in lemma t
     (Ï^R
     , Ï^Râ€²
     , (Î» Ïƒ pr â†’ let open Simulate SimulationNormalise in sim (lookup Ï pr) Ï^R))
\end{code}}
\end{corollary}


%Finally, we use \AR{Fusable} to prove that our
%definition of pretty-printing ignores \AR{Renamings}. In other
%words, as long as the names provided for the free variables are
%compatible after the renaming and as long as the name supplies
%are equal then the string produced, as well as the state of the
%name supply at the end of the process, are equal.

%\begin{corollary}[Renaming-Printing fusion]
\AgdaHide{
\begin{code}
RenamingPrettyPrintingFusable : Fusable Renaming Printing Printing PropEq
  (Î» Ï^A Ï^B â†’ `âˆ€[ PropEq ] (select Ï^A Ï^B))
  (mkRModel (Î» p q â†’ âˆ€ {namesâ‚ namesâ‚‚} â†’ namesâ‚ â‰¡ namesâ‚‚ â†’ runP p namesâ‚ â‰¡ runP q namesâ‚‚))
RenamingPrettyPrintingFusable = record
  { reify^A   = id
  ; ğ“¥^Râ€¿âˆ™   = Î» {Î“} {Î”} {Î˜} {Ïƒ} {Ï^A} {Ï^B} {Ï^C} {u^B} {u^C} Ï^R eq â†’ pack^R ((Î» {Ïƒ} v â†’ [_,,_] {P = Î» Ïƒ v â†’ lookup (select (step Ï^A `âˆ™ ze) (Ï^B `âˆ™ u^B)) v â‰¡ lookup (Ï^C `âˆ™ u^C) v} eq (Î» Ïƒ v â†’ lookup^R Ï^R v) Ïƒ v))
  ; ğ“¥^Râ€¿th  = Î» _ Ï^R â†’ pack^R (PEq.cong (mkN âˆ˜ getN) âˆ˜ lookup^R Ï^R)
  ; RâŸ¦varâŸ§   = Î» v Ï^R â†’ PEq.congâ‚‚ (Î» n ns â†’ getN n , ns) (lookup^R Ï^R v)
  ; RâŸ¦Î»âŸ§     = Î» t r Ï^R â†’ Î» { {nâ‚ âˆ· nâ‚s} {nâ‚‚ âˆ· nâ‚‚s} eq â†’
                        let (neq   , nseq) = âˆ·-inj eq
                            (ihstr , ihns) = both (r (step refl) (PEq.cong mkN neq) (PEq.cong â™­ nseq))
                        in PEq.congâ‚‚ _,_ (PEq.congâ‚‚ (Î» n str â†’ "Î»" ++ n ++ ". " ++ str) neq ihstr) ihns }
  ; RâŸ¦$âŸ§     = Î» f t {Ï^A} {Ï^B} {Ï^C} ihf iht Ï^R eq â†’
                        let (ihstrf , eqâ‚) = both (ihf eq)
                            (ihstrt , eqâ‚‚) = both (iht eqâ‚)
                        in PEq.congâ‚‚ _,_ (PEq.congâ‚‚ (Î» strf strt â†’ strf ++ " (" ++ strt ++ ")") ihstrf ihstrt) eqâ‚‚
  ; RâŸ¦âŸ¨âŸ©âŸ§    = Î» _ â†’ PEq.cong _
  ; RâŸ¦ttâŸ§    = Î» _ â†’ PEq.cong _
  ; RâŸ¦ffâŸ§    = Î» _ â†’ PEq.cong _
  ; RâŸ¦ifâŸ§    = Î» b l r {Ï^A} {Ï^B} {Ï^C} Ï^R ihb ihl ihr eq â†’
                       let (ihstrb , eqâ‚) = both (ihb eq)
                           (ihstrl , eqâ‚‚) = both (ihl eqâ‚)
                           (ihstrr , eqâ‚ƒ) = both (ihr eqâ‚‚)
                       in PEq.congâ‚‚ _,_ (PEq.congâ‚‚ (Î» strb strlr â†’ "if (" ++ strb ++ ") then (" ++ strlr)
                                        ihstrb (PEq.congâ‚‚ (Î» strl strr â†’ strl ++ ") else (" ++ strr ++ ")")
                                        ihstrl ihstrr)) eqâ‚ƒ }

tailComm : (Î” Î“ : Cx Ty) {names : Stream String} â†’
           tail (projâ‚‚ (nameContext Î” Î“ names)) â‰¡ projâ‚‚ (nameContext Î” Î“ (tail names))
tailComm Î” Îµ        = PEq.refl
tailComm Î” (Î“ âˆ™ _)  = PEq.cong tail (tailComm Î” Î“)

proof : (Î” Î“ : Cx Ty) {names : Stream String} â†’ projâ‚‚ (nameContext Î” Î“ names) â‰¡ Stream.drop (size Î“) names
proof Î” Îµ                = PEq.refl
proof Î” (Î“ âˆ™ x) {n âˆ· ns} = PEq.trans (tailComm Î” Î“) (proof Î” Î“)

ren-print : {Î“ : Cx Ty} {Ïƒ : Ty} (t : Tm Ïƒ Îµ) (inc : Îµ âŠ† Î“) â†’
\end{code}
\begin{code}
 print (th^Tm Ïƒ inc t) â‰¡ projâ‚ (runP (Eval.sem Printing `Îµ t) (Stream.drop (size Î“) names))
\end{code}
\begin{code}
ren-print {Î“} t inc = PEq.cong projâ‚ (lemma t (pack^R (Î» ())) (proof Î“ Î“))
  where open Fusion RenamingPrettyPrintingFusable
\end{code}}
%\end{corollary}