


The evidence that \AB{𝓢^A}, \AB{𝓢^B} and \AB{𝓢^C} are such
that \AB{𝓢^A} followed by \AB{𝓢^B} is equivalent
to \AB{𝓢^C} (e.g. \AF{Substitution} followed by \AF{Renaming}
can be reduced to \AF{Substitution}) is packed in a record
\AR{Fusable} indexed by the three semantics but also three
relations. The first one (\AB{𝓥^R_{BC}}) states what it means
for two environment values of \AB{𝓢^B} and \AB{𝓢^C} respectively
to be related. The second one (\AB{𝓥^R}) characterises the triples
of environments (one for each one of the semantics) which are
compatible. The last one (\AB{𝓒^R}) relates values
in \AB{𝓢^B} and \AB{𝓢^C}'s models.
\begin{code}
record Fusable {ℓ^EA ℓ^MA ℓ^EB ℓ^MB ℓ^EC ℓ^MC ℓ^RE ℓ^REBC ℓ^RM : Level} {𝓥^A : Model ℓ^EA} {𝓥^B : Model ℓ^EB} {𝓥^C : Model ℓ^EC} {𝓒^A : Model ℓ^MA} {𝓒^B : Model ℓ^MB} {𝓒^C : Model ℓ^MC} (𝓢^A : Semantics 𝓥^A 𝓒^A)
 (𝓢^B : Semantics 𝓥^B 𝓒^B) (𝓢^C : Semantics 𝓥^C 𝓒^C)
 (𝓥^R‿BC : RModel 𝓥^B 𝓥^C ℓ^REBC)
 (𝓥^R :  {Θ Δ Γ : Cx Ty} → (Γ -Env) 𝓥^A Δ → (Δ -Env) 𝓥^B Θ →
         (Γ -Env) 𝓥^C Θ → Set ℓ^RE)
 (𝓒^R : RModel 𝓒^B 𝓒^C ℓ^RM) : Set (ℓ^RM ⊔ ℓ^RE ⊔ ℓ^EC ⊔ ℓ^EB ⊔ ℓ^EA ⊔ ℓ^MA ⊔ ℓ^REBC) where
\end{code}
\AgdaHide{
\begin{code}
 module 𝓢^A = Semantics 𝓢^A
 module 𝓢^B = Semantics 𝓢^B
 module 𝓢^C = Semantics 𝓢^C
 sem^A = Eval.sem 𝓢^A
 sem^B = Eval.sem 𝓢^B
 sem^C = Eval.sem 𝓢^C
 field
\end{code}}

As before, most of the fields of this record describe
what structure these relations need to have. However, we start with something
slightly different: given that we are planing to run the \AR{Semantics} \AB{𝓢^B}
\emph{after} having run \AB{𝓢^A}, we need two components: a way to extract a
term from an \AB{𝓢^A} and a way to manufacture a dummy \AB{𝓢^A} value when
going under a binder. Our first two fields are therefore:
\begin{code}
  reify^A    : {σ : Ty} → [  𝓒^A σ ⟶ Tm σ  ]
  var‿0^A    : {σ : Ty} → [  σ ⊢ 𝓥^A σ     ]
\end{code}
Then come two constraints dealing with the relations talking
about evaluation environments. \ARF{𝓥^R‿∙} tells us how to
extend related environments: one should be able to push related
values onto the environments for \AB{𝓢^B} and \AB{𝓢^C} whilst
merely extending the one for \AB{𝓢^A} with the token value \ARF{var‿0^A}.

\ARF{𝓥^R‿th} guarantees that it is always possible to thin
the environments for \AB{𝓢^B} and \AB{𝓢^C} in a \AB{𝓥^R}
preserving manner.\vspace*{ -1em}
\begin{code}
  𝓥^R‿∙   :  {Γ Δ Θ : Cx Ty} {σ : Ty} {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ} {u^B : 𝓥^B σ Θ} {u^C : 𝓥^C σ Θ} → 𝓥^R ρ^A ρ^B ρ^C → rmodel 𝓥^R‿BC u^B u^C →
             let ρ^A′ = th[ 𝓢^A.th ] (step refl) ρ^A `∙ var‿0^A
             in 𝓥^R ρ^A′ (ρ^B `∙ u^B) (ρ^C `∙ u^C)
\end{code}\vspace*{ -1.75em}
\begin{code}
  𝓥^R‿th  :  {Γ Δ Θ E : Cx Ty} (inc : Θ ⊆ E) {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ} → 𝓥^R ρ^A ρ^B ρ^C →
             𝓥^R ρ^A (th[ 𝓢^B.th ] inc ρ^B) (th[ 𝓢^C.th ] inc ρ^C)
\end{code}
Then we have the relational counterpart of the various term constructors.
We can once more introduce an extra definition \AF{𝓡} which will make the type
of the combinators defined later on clearer. \AF{𝓡} relates a term and three
environments by stating that the computation one gets by sequentially evaluating
the term in the first and then the second environment is related to the one
obtained by directly evaluating the term in the third environment.
\AgdaHide{
\begin{code}
 𝓡 : {σ : Ty} {Γ Δ Θ : Cx Ty} → Tm σ Γ → (Γ -Env) 𝓥^A Δ → (Δ -Env) 𝓥^B Θ → (Γ -Env) 𝓥^C Θ → Set _
\end{code}}
\begin{code}
 𝓡 t ρ^A ρ^B ρ^C = rmodel 𝓒^R  (sem^B ρ^B (reify^A (sem^A ρ^A t)))
                               (sem^C ρ^C t)
\end{code}
\AgdaHide{
\begin{code}
 field
\end{code}}
As with the previous section, only a handful of these combinators are out
of the ordinary. We will start with the \AIC{`var} case. It states that
fusion indeed happens when evaluating a variable using related environments.
\begin{code}
  R⟦var⟧  :  {Γ Δ Θ : Cx Ty} {σ : Ty} {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ} → ∀ v → 𝓥^R ρ^A ρ^B ρ^C → 𝓡 {σ} (`var v) ρ^A ρ^B ρ^C
\end{code}

The \AIC{`λ}-case puts some rather strong restrictions on the way
the $λ$-abstraction's body may be used by \AB{𝓢^A}: we assume it
is evaluated in an environment thinned by one variable and extended
using \ARF{var‿0^A}. But it is quite natural to have these restrictions:
given that \ARF{reify^A} quotes the result back, we are expecting this
type of evaluation in an extended context (i.e. under one lambda). And
it turns out that this is indeed enough for all of our examples.
The evaluation environments used by the semantics \AB{𝓢^B} and \AB{𝓢^C}
on the other hand can be arbitrarily thinned before being extended with
related values to be substituted for the variable bound by the \AIC{`λ}.\vspace*{ -1em}

\begin{code}
  R⟦λ⟧    :  {Γ Δ Θ : Cx Ty} {σ τ : Ty} {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ} (t : Tm τ (Γ ∙ σ))
             (r :  {E : Cx Ty} {u^B : 𝓥^B σ E} {u^C : 𝓥^C σ E} → ∀ inc → rmodel 𝓥^R‿BC u^B u^C →
                   let  ρ^A′ =  th[ 𝓢^A.th ] (step refl) ρ^A `∙ var‿0^A
                        ρ^B′ =  th[ 𝓢^B.th ] inc ρ^B `∙ u^B
                        ρ^C′ =  th[ 𝓢^C.th ] inc ρ^C `∙ u^C
                   in 𝓡 t ρ^A′ ρ^B′ ρ^C′) →
             𝓥^R ρ^A ρ^B ρ^C → 𝓡 (`λ t) ρ^A ρ^B ρ^C
\end{code}
The other cases (omitted here) are just stating that, given
the expected induction hypotheses, and the assumption that the three
environments are \AB{𝓥^R}-related we can deliver a proof that fusion
can happen on the compound expression.
\AgdaHide{
\begin{code}
  R⟦$⟧    : {Γ Δ Θ : Cx Ty} {σ τ : Ty} (f : Tm (σ `→ τ) Γ) (t : Tm σ Γ)
            {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ} →
            𝓡 f ρ^A ρ^B ρ^C → 𝓡 t ρ^A ρ^B ρ^C →
            𝓥^R ρ^A ρ^B ρ^C → 𝓡 (f `$ t) ρ^A ρ^B ρ^C
  R⟦⟨⟩⟧   : {Γ Δ Θ : Cx Ty} {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ} → 𝓥^R ρ^A ρ^B ρ^C → 𝓡 `⟨⟩ ρ^A ρ^B ρ^C
  R⟦tt⟧   : {Γ Δ Θ : Cx Ty} {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ} → 𝓥^R ρ^A ρ^B ρ^C → 𝓡 `tt ρ^A ρ^B ρ^C
  R⟦ff⟧   : {Γ Δ Θ : Cx Ty} {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ} → 𝓥^R ρ^A ρ^B ρ^C → 𝓡 `ff ρ^A ρ^B ρ^C
  R⟦if⟧ : {Γ Δ Θ : Cx Ty} {σ : Ty} (b : Tm `2 Γ) (l r : Tm σ Γ)
            {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ} →
            𝓥^R ρ^A ρ^B ρ^C →
            𝓡 b ρ^A ρ^B ρ^C →
            𝓡 l ρ^A ρ^B ρ^C →
            𝓡 r ρ^A ρ^B ρ^C →
            𝓡 (`if b l r) ρ^A ρ^B ρ^C
\end{code}}

As with simulation, we measure the utility of this framework
by the way we can prove its fundamental lemma and then
obtain useful corollaries. Once again, having carefully
identified what the constraints should be, proving the fundamental lemma
is not a problem:

\begin{theorem}[Fundamental Lemma of Fusable Semantics]
Given three Semantics \AB{𝓢^A}, \AB{𝓢^B} and \AB{𝓢^C} which are fusable
with respect to the relations \AB{𝓥^R‿BC} for values of \AB{𝓢^B} and \AB{𝓢^C},
\AB{𝓥^R} for environemnts and \AB{𝓒^R} for computations, we have that:

For any term \AB{t} and environments \AB{ρ^A}, \AB{ρ^B}, and \AB{ρ^C}, if the
three environments are \AB{𝓥^R}-related then the semantics associated to \AB{t}
by \AB{𝓢^A} using \AB{ρ^A} followed by \AB{𝓢^B} using \AB{ρ^B} is \AB{𝓒^R}-related
to the one associated to \AB{t} by \AB{𝓢^C} using \AB{ρ^C}.
\end{theorem}
\begin{proof} The proof is by structural induction on \AB{t} using the
combinators to assemble the induction hypotheses.
\end{proof}
\AgdaHide{
\begin{code}
module Fusion {ℓ^EA ℓ^MA ℓ^EB ℓ^MB ℓ^EC ℓ^MC ℓ^RE ℓ^REB ℓ^RM : Level} {𝓥^A : Model ℓ^EA} {𝓥^B : Model ℓ^EB} {𝓥^C : Model ℓ^EC} {𝓒^A : Model ℓ^MA} {𝓒^B : Model ℓ^MB} {𝓒^C : Model ℓ^MC} {𝓢^A : Semantics 𝓥^A 𝓒^A} {𝓢^B : Semantics 𝓥^B 𝓒^B} {𝓢^C : Semantics 𝓥^C 𝓒^C} {𝓥^R‿BC : RModel 𝓥^B 𝓥^C ℓ^REB} {𝓥^R : {Θ Δ Γ : Cx Ty} (ρ^A : (Γ -Env) 𝓥^A Δ) (ρ^B : (Δ -Env) 𝓥^B Θ) (ρ^C : (Γ -Env) 𝓥^C Θ) → Set ℓ^RE} {𝓒^R : RModel 𝓒^B 𝓒^C ℓ^RM} (fusable : Fusable 𝓢^A 𝓢^B 𝓢^C 𝓥^R‿BC 𝓥^R 𝓒^R) where
  open Fusable fusable

  lemma :  {Γ Δ Θ : Cx Ty} {σ : Ty} (t : Tm σ Γ) {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ} (ρ^R : 𝓥^R ρ^A ρ^B ρ^C) →
           𝓡 t ρ^A ρ^B ρ^C
  lemma (`var v)       ρ^R = R⟦var⟧ v ρ^R
  lemma (f `$ t)       ρ^R = R⟦$⟧ f t (lemma f ρ^R) (lemma t ρ^R) ρ^R
  lemma (`λ t)         ρ^R = R⟦λ⟧ t (λ inc u^R → lemma t (𝓥^R‿∙ (𝓥^R‿th inc ρ^R) u^R)) ρ^R
  lemma `⟨⟩            ρ^R = R⟦⟨⟩⟧ ρ^R
  lemma `tt            ρ^R = R⟦tt⟧ ρ^R
  lemma `ff            ρ^R = R⟦ff⟧ ρ^R
  lemma (`if b l r)  ρ^R = R⟦if⟧ b l r ρ^R (lemma b ρ^R) (lemma l ρ^R) (lemma r ρ^R)
\end{code}}

\paragraph{The Special Case of Syntactic Semantics}

The translation from \AR{Syntactic} to \AR{Semantics} uses a lot
of constructors as their own semantic counterpart, it is hence possible to generate
evidence of \AR{Syntactic} triplets being fusable with much fewer assumptions.
We isolate them and prove the result generically to avoid repetition. A
\AR{SyntacticFusable} record packs the evidence for
\AR{Syntactic} semantics \AB{syn^A}, \AB{syn^B} and \AB{syn^C}. It is indexed
by these three \AR{Syntactic}s as well as two relations corresponding to the
\AB{𝓥^R_{BC}} and \AB{𝓥^R} ones of the \AR{Fusable} framework.
It contains the same \ARF{𝓥^R‿∙}, \ARF{𝓥^R‿th} and \ARF{R⟦var⟧}
fields as a \AR{Fusable} as well as a fourth one (\ARF{var‿0^{BC}})
saying that \AB{syn^B} and \AB{syn^C}'s respective \ARF{var‿0}s are
producing related values.
\AgdaHide{
\begin{code}
record SyntacticFusable
  {ℓ^EA ℓ^EB ℓ^EC ℓ^REBC ℓ^RE : Level} {𝓥^A : Model ℓ^EA} {𝓥^B : Model ℓ^EB} {𝓥^C : Model ℓ^EC} (synA : Syntactic 𝓥^A)
  (synB : Syntactic 𝓥^B)
  (synC : Syntactic 𝓥^C)
  (𝓥^R‿BC : RModel 𝓥^B 𝓥^C ℓ^REBC)
  (𝓥^R : {Θ Δ Γ : Cx Ty} (ρ^A : (Γ -Env) 𝓥^A Δ) (ρ^B : (Δ -Env) 𝓥^B Θ) (ρ^C : (Γ -Env) 𝓥^C Θ) → Set ℓ^RE)
  : Set (ℓ^RE ⊔ ℓ^REBC ⊔ ℓ^EC ⊔ ℓ^EB ⊔ ℓ^EA)
  where
  module Syn^A = Syntactic synA
  module Syn^B = Syntactic synB
  module Syn^C = Syntactic synC
  field
    𝓥^R‿∙ : ({Γ Δ Θ : Cx Ty} {σ : Ty} {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ}
               {u^B : 𝓥^B σ Θ} {u^C : 𝓥^C σ Θ} (ρ^R : 𝓥^R ρ^A ρ^B ρ^C) (u^R : rmodel 𝓥^R‿BC u^B u^C) →
               𝓥^R (th[ Syn^A.th ] (step refl) ρ^A `∙ Syn^A.var‿0)
                      (ρ^B `∙ u^B)
                      (ρ^C `∙ u^C))
    𝓥^R‿th : {Γ Δ Θ E : Cx Ty} (inc : Θ ⊆ E)
               {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ} (ρ^R : 𝓥^R ρ^A ρ^B ρ^C) →
               𝓥^R ρ^A(th[ Syn^B.th ] inc ρ^B) (th[ Syn^C.th ] inc ρ^C)
    R⟦var⟧  : {Γ Δ Θ : Cx Ty} {σ : Ty} {ρ^A : (Γ -Env) 𝓥^A Δ} {ρ^B : (Δ -Env) 𝓥^B Θ} {ρ^C : (Γ -Env) 𝓥^C Θ}
              → (v : Var σ Γ) → 𝓥^R ρ^A ρ^B ρ^C →
              Eval.sem (syntactic synB) ρ^B (Eval.sem (syntactic synA) ρ^A (`var v))
              ≡ Eval.sem (syntactic synC) ρ^C (`var v)
\end{code}}
\begin{code}
    var‿0^BC : {Γ : Cx Ty} {σ : Ty} → rmodel 𝓥^R‿BC {σ} {Γ ∙ σ} Syn^B.var‿0 Syn^C.var‿0
\end{code}

\begin{theorem}[Fundamental Lemma of Fusable Syntactics]
Given a \AR{SyntacticFusable} relating three \AR{Syntactic} semantics,
we get a \AR{Fusable} relating the corresponding \AR{Semantics} where
\AB{𝓒^R} is the propositional equality.
\end{theorem}
\begin{proof}The proof relies on the way the translation from \AR{Syntactic}
to \AR{Semantics} is formulated in \cref{syntactic}.
\end{proof}
\AgdaHide{
\begin{code}
syntacticFusable :  {ℓ^EA ℓ^EB ℓ^EC ℓ^RE ℓ^REBC : Level} {𝓥^A : Model ℓ^EA} {𝓥^B : Model ℓ^EB} {𝓥^C : Model ℓ^EC} {syn^A : Syntactic 𝓥^A} {syn^B : Syntactic 𝓥^B} {syn^C : Syntactic 𝓥^C} {𝓥^R‿BC : RModel 𝓥^B 𝓥^C ℓ^REBC} {𝓥^R : {Θ Δ Γ : Cx Ty} (ρ^A : (Γ -Env) 𝓥^A Δ) (ρ^B : (Δ -Env) 𝓥^B Θ) (ρ^C : (Γ -Env) 𝓥^C Θ) → Set ℓ^RE} (syn^R : SyntacticFusable syn^A syn^B syn^C 𝓥^R‿BC 𝓥^R) →
  Fusable (syntactic syn^A) (syntactic syn^B) (syntactic syn^C) 𝓥^R‿BC 𝓥^R PropEq
syntacticFusable synF =
  let open SyntacticFusable synF in
  record
    { reify^A    = id
    ; 𝓥^R‿∙   = 𝓥^R‿∙
    ; 𝓥^R‿th  = 𝓥^R‿th
    ; R⟦var⟧    = R⟦var⟧
    ; R⟦$⟧      = λ f t eqf eqt ρ^R → PEq.cong₂ _`$_ eqf eqt
    ; R⟦λ⟧      = λ t r ρ^R → PEq.cong `λ (r (step refl) var‿0^BC)
    ; R⟦⟨⟩⟧     = λ ρ^R → PEq.refl
    ; R⟦tt⟧     = λ ρ^R → PEq.refl
    ; R⟦ff⟧     = λ ρ^R → PEq.refl
    ; R⟦if⟧   = λ b l r ρ^R eqb eql → PEq.cong₂ (uncurry `if) (PEq.cong₂ _,_ eqb eql)
    }

`var-inj : {Γ : Cx Ty} {σ : Ty} {pr₁ pr₂ : Var σ Γ} (eq : (Tm σ Γ F.∋ `var pr₁) ≡ `var pr₂) → pr₁ ≡ pr₂
`var-inj PEq.refl = PEq.refl
\end{code}}

\begin{corollary}[Renaming-Renaming fusion]Given two renamings \AB{ρ} from
\AB{Γ} to \AB{Δ} and \AB{ρ′} from \AB{Δ} to \AB{Θ} and a term \AB{t} of type
\AB{σ} with free variables in \AB{Γ}, we have that:
\AgdaHide{
\begin{code}
RenamingFusable :
  SyntacticFusable  syntacticRenaming syntacticRenaming syntacticRenaming
                    PropEq (λ ρ^A ρ^B ρ^C → ∀ σ pr → lookup (select ρ^A ρ^B) pr ≡ lookup ρ^C pr)
RenamingFusable = record
  { 𝓥^R‿∙     = λ ρ^R eq → [ eq ,, ρ^R ]
  ; 𝓥^R‿th    = λ inc ρ^R σ pr → PEq.cong (lookup inc) (ρ^R σ pr)
  ; R⟦var⟧    = λ v ρ^R → PEq.cong `var (ρ^R _ v)
  ; var‿0^BC  = PEq.refl }

ren-ren : {Γ Δ Θ : Cx Ty} {σ : Ty} (ρ : Γ ⊆ Δ) (ρ′ : Δ ⊆ Θ) (t : Tm σ Γ) → 
\end{code}}
%<*renren>
\begin{code}
 th^Tm σ ρ′ (th^Tm σ ρ t) ≡ th^Tm σ (ρ′ [∘] ρ) t
\end{code}
%</renren>
\AgdaHide{
\begin{code}
ren-ren ρ ρ′ t = let open Fusion (syntacticFusable RenamingFusable) in lemma t (λ _ _ → PEq.refl)
\end{code}}
\end{corollary}

\begin{corollary}[Renaming-Substitution fusion]Given a renaming \AB{ρ} from
\AB{Γ} to \AB{Δ}, a substitution \AB{ρ′} from \AB{Δ} to \AB{Θ} and a term
\AB{t} of type \AB{σ} with free variables in \AB{Γ}, we have that:\vspace*{ -1.5em}
\AgdaHide{
\begin{code}
RenamingSubstitutionFusable :
  SyntacticFusable syntacticRenaming syntacticSubstitution syntacticSubstitution
  PropEq (λ ρ^A ρ^B ρ^C → ∀ σ pr → lookup ρ^B (lookup ρ^A pr) ≡ lookup ρ^C pr)
RenamingSubstitutionFusable = record
  { 𝓥^R‿∙   = λ ρ^R eq → [ eq ,, ρ^R ]
  ; 𝓥^R‿th  = λ inc ρ^R σ pr → PEq.cong (th^Tm σ inc) (ρ^R σ pr)
  ; R⟦var⟧    = λ v ρ^R → ρ^R _ v
  ; var‿0^BC   = PEq.refl }

ren-sub : {Γ Δ Θ : Cx Ty} {σ : Ty} (ρ : Γ ⊆ Δ) (ρ′ : (Δ -Env) Tm Θ) (t : Tm σ Γ) → 
\end{code}}
%<*rensub>
\begin{code}
 subst ρ′ (th^Tm σ ρ t) ≡ subst (ρ′ [∘] ρ) t
\end{code}
%</rensub>
\AgdaHide{
\begin{code}
ren-sub ρ ρ′ t = let open Fusion (syntacticFusable RenamingSubstitutionFusable) in lemma t (λ _ _ → PEq.refl)
\end{code}}
\end{corollary}

\begin{corollary}[Substitution-Renaming fusion]Given a substitution \AB{ρ}
from \AB{Γ} to \AB{Δ}, a renaming \AB{ρ′} from \AB{Δ} to \AB{Θ} and a term
\AB{t} of type \AB{σ} with free variables in \AB{Γ}, we have that:\vspace*{ -1.5em}
\AgdaHide{
\begin{code}
SubstitutionRenamingFusable :
  SyntacticFusable syntacticSubstitution syntacticRenaming syntacticSubstitution
  (mkRModel (_≡_ ∘ `var)) (λ ρ^A ρ^B ρ^C → ∀ σ pr → th^Tm σ ρ^B (lookup ρ^A pr) ≡ lookup ρ^C pr)
SubstitutionRenamingFusable =
  let module RenRen = Fusion (syntacticFusable RenamingFusable) in
  record { 𝓥^R‿∙   = λ {_} {_} {_} {_} {ρ^A} {ρ^B} {ρ^C} ρ^R eq → [ eq ,, (λ σ pr →
                         PEq.trans (RenRen.lemma (lookup ρ^A pr) (λ _ _ → PEq.refl))
                                   (ρ^R σ pr)) ]
         ; 𝓥^R‿th  = λ inc {ρ^A} {ρ^B} {ρ^C} ρ^R σ pr →
                         PEq.trans (PEq.sym (RenRen.lemma (lookup ρ^A pr) (λ _ _ → PEq.refl)))
                                   (PEq.cong (th^Tm σ inc) (ρ^R σ pr))
         ; R⟦var⟧    = λ v ρ^R → ρ^R _ v
         ; var‿0^BC   = PEq.refl }
sub-ren : {Γ Δ Θ : Cx Ty} {σ : Ty} (ρ : (Γ -Env) Tm Δ) (ρ′ : Δ ⊆ Θ) (t : Tm σ Γ) → 
\end{code}}
%<*subren>
\begin{code}
 th^Tm σ ρ′ (subst ρ t) ≡ subst (map^Env (th^Tm _ ρ′) ρ) t
\end{code}
%</subren>
\AgdaHide{
\begin{code}
sub-ren ρ ρ′ t = let open Fusion (syntacticFusable SubstitutionRenamingFusable) in lemma t (λ _ _ → PEq.refl)
\end{code}}
\end{corollary}

\begin{corollary}[Substitution-Substitution fusion]Given two substitutitons,
\AB{ρ} from \AB{Γ} to \AB{Δ} and \AB{ρ′} from \AB{Δ} to \AB{Θ}, and a term
\AB{t} of type \AB{σ} with free variables in \AB{Γ}, we have that:\vspace*{ -1.5em}
\AgdaHide{
\begin{code}
SubstitutionFusable :
  SyntacticFusable syntacticSubstitution syntacticSubstitution syntacticSubstitution
  PropEq (λ ρ^A ρ^B ρ^C → ∀ σ pr → subst ρ^B (lookup ρ^A pr) ≡ lookup ρ^C pr)
SubstitutionFusable =
  let module RenSubst = Fusion (syntacticFusable RenamingSubstitutionFusable)
      module SubstRen = Fusion (syntacticFusable SubstitutionRenamingFusable) in
  record { 𝓥^R‿∙   = λ {_} {_} {_} {_} {ρ^A} {ρ^B} {ρ^C} ρ^R eq → [ eq ,, (λ σ pr →
                         PEq.trans (RenSubst.lemma (lookup ρ^A pr) (λ _ _ → PEq.refl))
                                   (ρ^R σ pr)) ]
         ; 𝓥^R‿th  = λ inc {ρ^A} {ρ^B} {ρ^C} ρ^R σ pr →
                         PEq.trans (PEq.sym (SubstRen.lemma (lookup ρ^A pr) (λ _ _ → PEq.refl)))
                                   (PEq.cong (th^Tm σ inc) (ρ^R σ pr))
         ; R⟦var⟧    = λ v ρ^R → ρ^R _ v
         ; var‿0^BC   = PEq.refl }

ifRenNorm :
      {Γ Δ Θ : Cx Ty} {σ : Ty} (b : Tm `2 Γ) (l r : Tm σ Γ)
      {ρ^A : Γ ⊆ Δ} {ρ^B : (Δ -Env) Kr Θ}
      {ρ^C : (Γ -Env) Kr Θ} →
      (ρ^R : (σ : Ty) (pr : Var σ Γ) → PER σ (lookup ρ^B (lookup ρ^A pr)) (lookup ρ^C pr)) →
      Eval.sem Normalise ρ^B (th^Tm `2 ρ^A b) ≡ Eval.sem Normalise ρ^C b →
      PER σ (Eval.sem Normalise ρ^B (th^Tm σ ρ^A l)) (Eval.sem Normalise ρ^C l) →
      PER σ (Eval.sem Normalise ρ^B (th^Tm σ ρ^A r)) (Eval.sem Normalise ρ^C r) →
      PER σ (Eval.sem Normalise ρ^B (th^Tm σ ρ^A (`if b l r))) (Eval.sem Normalise ρ^C (`if b l r))
ifRenNorm b l r {ρ^A} {ρ^B} {ρ^C} ρ^R eqb eql eqr
  with Eval.sem Normalise  ρ^B (th^Tm _ ρ^A b)
     | Eval.sem Normalise ρ^C b
ifRenNorm b l r ρ^R PEq.refl eql eqr | `ne _ t | `ne _ .t =
  reflect^PER _ (PEq.cong₂ (uncurry `if) (PEq.cong₂ _,_ PEq.refl (reify^PER _ eql)) (reify^PER _ eqr))
ifRenNorm b l r ρ^R () eql eqr | `ne _ t | `tt
ifRenNorm b l r ρ^R () eql eqr | `ne _ t | `ff
ifRenNorm b l r ρ^R () eql eqr | `tt | `ne _ t
ifRenNorm b l r ρ^R PEq.refl eql eqr | `tt | `tt = eql
ifRenNorm b l r ρ^R () eql eqr | `tt | `ff
ifRenNorm b l r ρ^R () eql eqr | `ff | `ne _ t
ifRenNorm b l r ρ^R () eql eqr | `ff | `tt
ifRenNorm b l r ρ^R PEq.refl eql eqr | `ff | `ff = eqr
sub-sub : {Γ Δ Θ : Cx Ty} {σ : Ty} (ρ : (Γ -Env) Tm Δ) (ρ′ : (Δ -Env) Tm Θ) (t : Tm σ Γ) → 
\end{code}}
%<*subsub>
\begin{code}
 subst ρ′ (subst ρ t) ≡ subst (map^Env (subst ρ′) ρ) t
\end{code}
%</subsub>
\AgdaHide{
\begin{code}
sub-sub ρ ρ′ t = let open Fusion (syntacticFusable SubstitutionFusable) in lemma t (λ _ _ → PEq.refl)
\end{code}}
\end{corollary}

These four lemmas are usually proven in painful separation. Here
we discharged them by rapid successive instantiation of our framework,
using the earlier results to satisfy the later constraints.
We are not limited to \AR{Syntactic} statements:

\paragraph{Examples of Fusable Semantics}

The most simple example of \AR{Fusable} \AR{Semantics} involving a non
\AR{Syntactic} one is probably the proof that \AR{Renaming} followed
by \AR{Normalise^{βιξη}} is equivalent to NBE with an adjusted environment.

\begin{corollary}[Renaming-Normalise fusion] Given a renaming \AB{ρ}
from \AB{Γ} to \AB{Δ}, an environment of values \AB{ρ′} from \AB{Δ} to
\AB{Θ} such that they are all equal to themselves in the \AF{PER} and
a term \AB{t} of type \AB{σ} with free variables in \AB{Γ}, we have that:\vspace*{ -1.5em}
\AgdaHide{
\begin{code}
RenamingNormaliseFusable : Fusable Renaming Normalise Normalise PER′
  (λ ρ^A ρ^B ρ^C → ∀ σ pr → PER σ (lookup ρ^B (lookup ρ^A pr)) (lookup ρ^C pr)) PER′
RenamingNormaliseFusable =
  record
    { reify^A   = id
    ; 𝓥^R‿∙  = λ ρ^R u^R → [ u^R ,, ρ^R ]
    ; 𝓥^R‿th = λ inc ρ^R → λ σ pr → th^PER σ inc (ρ^R σ pr)
    ; R⟦var⟧   = λ v ρ^R → ρ^R _ v
    ; R⟦$⟧     = λ _ _ r eq _ → r refl eq
    ; R⟦λ⟧     = λ _ r _ inc eq → r inc eq
    ; R⟦⟨⟩⟧    = λ _ → ⟨⟩
    ; R⟦tt⟧    = λ _ → PEq.refl
    ; R⟦ff⟧    = λ _ → PEq.refl
    ; R⟦if⟧  = ifRenNorm
    }

ren-nbe : {Γ Δ Θ : Cx Ty} {σ : Ty} (ρ : Γ ⊆ Δ) (ρ′ : (Δ -Env) Kr Θ) (t : Tm σ Γ) (ρ^R : `∀[ PER′ ] ρ′ ρ′) →
\end{code}}
\begin{code}
 PER σ (nbe ρ′ (th^Tm σ ρ t)) (nbe (select ρ ρ′) t)
\end{code}
\AgdaHide{
\begin{code}
ren-nbe ρ ρ′ t ρ^R = let open Fusion RenamingNormaliseFusable
                     in lemma t (λ σ pr → lookup^R ρ^R (lookup ρ pr))
\end{code}}
\end{corollary}

\AgdaHide{
\begin{code}
ifSubstNorm :
     {Γ Δ Θ : Cx Ty} {σ : Ty} (b : Tm `2 Γ) (l r : Tm σ Γ)
      {ρ^A : (Γ -Env) Tm Δ} {ρ^B : (Δ -Env) Kr Θ}
      {ρ^C : (Γ -Env) Kr Θ} →
      (`∀[ PER′ ] ρ^B ρ^B) ×
      ((σ₁ : Ty) (pr : Var σ₁ Γ) {Θ₁ : Cx Ty} (inc : Θ ⊆ Θ₁) →
       PER σ₁
       (Eval.sem Normalise (pack (λ {σ} → th^Kr σ inc ∘ lookup ρ^B)) (lookup ρ^A pr))
       (th^Kr σ₁ inc (lookup ρ^C pr)))
      ×
      ((σ₁ : Ty) (pr : Var σ₁ Γ) →
       PER σ₁ (Eval.sem Normalise ρ^B (lookup ρ^A  pr)) (lookup ρ^C pr)) →
      Eval.sem Normalise ρ^B (subst ρ^A b) ≡ Eval.sem Normalise ρ^C b →
      PER σ (Eval.sem Normalise ρ^B (subst ρ^A l)) (Eval.sem Normalise ρ^C l) →
      PER σ (Eval.sem Normalise ρ^B (subst ρ^A r)) (Eval.sem Normalise ρ^C r) →
      PER σ (Eval.sem Normalise ρ^B (subst ρ^A (`if b l r))) (Eval.sem Normalise ρ^C (`if b l r))
ifSubstNorm b l r {ρ^A} {ρ^B} {ρ^C} ρ^R eqb eql eqr
  with Eval.sem Normalise ρ^B (subst ρ^A b)
     | Eval.sem Normalise ρ^C b
ifSubstNorm b l r ρ^R PEq.refl eql eqr | `ne _ t | `ne _ .t =
  reflect^PER _ (PEq.cong₂ (uncurry `if) (PEq.cong₂ _,_ PEq.refl (reify^PER _ eql)) (reify^PER _ eqr))
ifSubstNorm b l r ρ^R () eql eqr | `ne _ t | `tt
ifSubstNorm b l r ρ^R () eql eqr | `ne _ t | `ff
ifSubstNorm b l r ρ^R () eql eqr | `tt | `ne _ t
ifSubstNorm b l r ρ^R PEq.refl eql eqr | `tt | `tt = eql
ifSubstNorm b l r ρ^R () eql eqr | `tt | `ff
ifSubstNorm b l r ρ^R () eql eqr | `ff | `ne _ t
ifSubstNorm b l r ρ^R () eql eqr | `ff | `tt
ifSubstNorm b l r ρ^R PEq.refl eql eqr | `ff | `ff = eqr

th-refl : {Γ : Cx Ty} (σ : Ty) {T U : Kr σ Γ} →
          PER σ T U → PER σ (th^Kr σ refl T) U
th-refl `1     eq = ⟨⟩
th-refl `2     eq = PEq.trans (th^nf-refl _) eq
th-refl (σ `→ τ)  eq = eq

th^2 : {Θ Δ Γ : Cx Ty} (σ : Ty) (inc₁ : Γ ⊆ Δ) (inc₂ : Δ ⊆ Θ) {T U : Kr σ Γ} →
       PER σ T U → PER σ (th^Kr σ inc₂ (th^Kr σ inc₁ T)) (th^Kr σ (select inc₁ inc₂) U)
th^2 `1     inc₁ inc₂ eq = ⟨⟩
th^2 `2     inc₁ inc₂ eq = PEq.trans (th^nf-trans inc₁ inc₂ _) (PEq.cong (th^nf `2 (select inc₁ inc₂)) eq)
th^2 (σ `→ τ)  inc₁ inc₂ eq = λ inc₃ → eq (select inc₁ (select inc₂ inc₃))
\end{code}}

Then, we use the framework to prove that to \AR{Normalise^{βιξη}} by
Evaluation after a \AR{Substitution} amounts to normalising the original
term where the substitution has been evaluated first. The constraints
imposed on the environments might seem quite restrictive but they are
actually similar to the Uniformity condition described by C. Coquand~(\citeyear{coquand2002formalised})
in her detailed account of NBE for a ST$λ$C with explicit substitution.


\begin{corollary}[Substitution-Normalise fusion]Given a substitution \AB{ρ}
from \AB{Γ} to \AB{Δ}, an environment of values \AB{ρ′} from \AB{Δ} to \AB{Θ}
such that all these values are equal to themselves and thinning and evaluation
in \AB{ρ′} commute, and a term \AB{t} of type \AB{σ} with free variables in \AB{Γ},
we have that:
\AgdaHide{
\begin{code}
SubstitutionNormaliseFusable : Fusable  Substitution Normalise Normalise
  PER′
  (λ ρ^A ρ^B ρ^C → `∀[ PER′ ] ρ^B ρ^B
                 × ((σ : Ty) (pr : Var σ _) {Θ : Cx Ty} (inc : _ ⊆ Θ) →
                      PER σ (Eval.sem Normalise (pack (λ {σ} pr → th^Kr σ inc (lookup ρ^B pr))) (lookup ρ^A pr)) (th^Kr σ inc (lookup ρ^C pr)))
                 × ((σ : Ty) (pr : Var σ _) → PER σ (Eval.sem Normalise ρ^B (lookup ρ^A pr)) (lookup ρ^C pr)))
  PER′
SubstitutionNormaliseFusable =
  let module RenNorm = Fusion RenamingNormaliseFusable
      module EqNorm  = Simulate SimulationNormalise in
  record
    { reify^A   = id
    ; 𝓥^R‿∙  = λ {_} {_} {_} {_} {ρ^A} {ρ^B} {ρ^C} ρ^R u^R →
                     (proj₁ ρ^R ∙^R refl^PER _ u^R)
                   , [ (λ {Θ} inc → th^PER _ inc u^R)
                     ,, (λ σ pr {Θ} inc →
                       trans^PER σ (RenNorm.lemma (lookup ρ^A pr)
                                                    (λ σ pr → th^PER σ inc (lookup^R (proj₁ ρ^R) pr)))
                                    ((proj₁ ∘ proj₂) ρ^R σ pr inc)) ]
                     , [ u^R ,, (λ σ pr → trans^PER σ (RenNorm.lemma (lookup ρ^A pr) (λ _ → lookup^R (proj₁ ρ^R)))
                                          ((proj₂ ∘ proj₂) ρ^R σ pr)) ]
    ; 𝓥^R‿th = λ inc {ρ^A} ρ^R → pack^R (λ pr → th^PER _ inc (lookup^R (proj₁ ρ^R) pr))
                          , (λ σ pr inc′ →
       trans^PER σ (EqNorm.sim (lookup ρ^A pr) (pack^R (λ {τ} v → trans^PER τ (th^2 τ inc inc′ (lookup^R (proj₁ ρ^R) v)) (th^PER τ (select inc inc′) (lookup^R (proj₁ ρ^R) v)))))
       (trans^PER σ ((proj₁ (proj₂ ρ^R)) σ pr (select inc inc′))
       (sym^PER σ (th^2 σ inc inc′ (refl^PER σ (sym^PER σ (proj₂ (proj₂ ρ^R) σ pr)))))))
                          , (λ σ pr → (proj₁ ∘ proj₂) ρ^R σ pr inc)
    ; R⟦var⟧   = λ v ρ^R → (proj₂ ∘ proj₂) ρ^R _ v
    ; R⟦$⟧     = λ _ _ r eq _ → r refl eq
    ; R⟦λ⟧     = λ _ r _ inc eq → r inc eq
    ; R⟦⟨⟩⟧    = λ _ → ⟨⟩
    ; R⟦tt⟧    = λ _ → PEq.refl
    ; R⟦ff⟧    = λ _ → PEq.refl
    ; R⟦if⟧  = ifSubstNorm
    }

both : {A B : Set} {a₁ a₂ : A} {b₁ b₂ : B} (eq : (A × B F.∋ a₁ , b₁) ≡ (a₂ , b₂)) → a₁ ≡ a₂ × b₁ ≡ b₂
both PEq.refl = PEq.refl , PEq.refl

∷-inj : {A : Set} {a b : A} {as bs : ∞ (Stream A)} (eq : (Stream A F.∋ a ∷ as) ≡ b ∷ bs) → a ≡ b × as ≡ bs
∷-inj PEq.refl = PEq.refl , PEq.refl

sub-nbe : {Γ Δ Θ : Cx Ty} {σ : Ty} (ρ : (Γ -Env) Tm Δ) (ρ′ : (Δ -Env) Kr Θ) (t : Tm σ Γ) (ρ^R : `∀[ PER′ ] ρ′ ρ′) → ∀ ρ^R′ →
\end{code}}
%<*subnbe>
\begin{code}
 PER σ (nbe ρ′ (subst ρ t)) (nbe (map^Env (nbe ρ′) ρ) t)
\end{code}
%</subnbe>
\AgdaHide{
\begin{code}
sub-nbe ρ ρ′ t ρ^R ρ^R′ =
  let open Fusion SubstitutionNormaliseFusable
  in lemma t
     (ρ^R
     , ρ^R′
     , (λ σ pr → let open Simulate SimulationNormalise in sim (lookup ρ pr) ρ^R))
\end{code}}
\end{corollary}


%Finally, we use \AR{Fusable} to prove that our
%definition of pretty-printing ignores \AR{Renamings}. In other
%words, as long as the names provided for the free variables are
%compatible after the renaming and as long as the name supplies
%are equal then the string produced, as well as the state of the
%name supply at the end of the process, are equal.

%\begin{corollary}[Renaming-Printing fusion]
\AgdaHide{
\begin{code}
RenamingPrettyPrintingFusable : Fusable Renaming Printing Printing PropEq
  (λ ρ^A ρ^B → `∀[ PropEq ] (select ρ^A ρ^B))
  (mkRModel (λ p q → ∀ {names₁ names₂} → names₁ ≡ names₂ → runP p names₁ ≡ runP q names₂))
RenamingPrettyPrintingFusable = record
  { reify^A   = id
  ; 𝓥^R‿∙   = λ {Γ} {Δ} {Θ} {σ} {ρ^A} {ρ^B} {ρ^C} {u^B} {u^C} ρ^R eq → pack^R ((λ {σ} v → [_,,_] {P = λ σ v → lookup (select (step ρ^A `∙ ze) (ρ^B `∙ u^B)) v ≡ lookup (ρ^C `∙ u^C) v} eq (λ σ v → lookup^R ρ^R v) σ v))
  ; 𝓥^R‿th  = λ _ ρ^R → pack^R (PEq.cong (mkN ∘ getN) ∘ lookup^R ρ^R)
  ; R⟦var⟧   = λ v ρ^R → PEq.cong₂ (λ n ns → getN n , ns) (lookup^R ρ^R v)
  ; R⟦λ⟧     = λ t r ρ^R → λ { {n₁ ∷ n₁s} {n₂ ∷ n₂s} eq →
                        let (neq   , nseq) = ∷-inj eq
                            (ihstr , ihns) = both (r (step refl) (PEq.cong mkN neq) (PEq.cong ♭ nseq))
                        in PEq.cong₂ _,_ (PEq.cong₂ (λ n str → "λ" ++ n ++ ". " ++ str) neq ihstr) ihns }
  ; R⟦$⟧     = λ f t {ρ^A} {ρ^B} {ρ^C} ihf iht ρ^R eq →
                        let (ihstrf , eq₁) = both (ihf eq)
                            (ihstrt , eq₂) = both (iht eq₁)
                        in PEq.cong₂ _,_ (PEq.cong₂ (λ strf strt → strf ++ " (" ++ strt ++ ")") ihstrf ihstrt) eq₂
  ; R⟦⟨⟩⟧    = λ _ → PEq.cong _
  ; R⟦tt⟧    = λ _ → PEq.cong _
  ; R⟦ff⟧    = λ _ → PEq.cong _
  ; R⟦if⟧    = λ b l r {ρ^A} {ρ^B} {ρ^C} ρ^R ihb ihl ihr eq →
                       let (ihstrb , eq₁) = both (ihb eq)
                           (ihstrl , eq₂) = both (ihl eq₁)
                           (ihstrr , eq₃) = both (ihr eq₂)
                       in PEq.cong₂ _,_ (PEq.cong₂ (λ strb strlr → "if (" ++ strb ++ ") then (" ++ strlr)
                                        ihstrb (PEq.cong₂ (λ strl strr → strl ++ ") else (" ++ strr ++ ")")
                                        ihstrl ihstrr)) eq₃ }

tailComm : (Δ Γ : Cx Ty) {names : Stream String} →
           tail (proj₂ (nameContext Δ Γ names)) ≡ proj₂ (nameContext Δ Γ (tail names))
tailComm Δ ε        = PEq.refl
tailComm Δ (Γ ∙ _)  = PEq.cong tail (tailComm Δ Γ)

proof : (Δ Γ : Cx Ty) {names : Stream String} → proj₂ (nameContext Δ Γ names) ≡ Stream.drop (size Γ) names
proof Δ ε                = PEq.refl
proof Δ (Γ ∙ x) {n ∷ ns} = PEq.trans (tailComm Δ Γ) (proof Δ Γ)

ren-print : {Γ : Cx Ty} {σ : Ty} (t : Tm σ ε) (inc : ε ⊆ Γ) →
\end{code}
\begin{code}
 print (th^Tm σ inc t) ≡ proj₁ (runP (Eval.sem Printing `ε t) (Stream.drop (size Γ) names))
\end{code}
\begin{code}
ren-print {Γ} t inc = PEq.cong proj₁ (lemma t (pack^R (λ ())) (proof Γ Γ))
  where open Fusion RenamingPrettyPrintingFusable
\end{code}}
%\end{corollary}


\section{Future and Related Work}

The programming part of this work can be replicated in Haskell and a translation
of the definitions is available in the paper's
repository~\cite{repo}
The subtleties of working with dependent types in Haskell~\cite{lindley2014hasochism}
are outside the scope of this paper.

If the Tagless and Typeful NbE procedure derived in Haskell from our Semantics
framework is to the best of our knowledge the first of its kind, Danvy,
Keller and Puech have achieved a similar goal in OCaml~(\citeyear{danvytagless}).
But their formalisation uses parametric higher order abstract syntax~\cite{chlipala2008parametric}
freeing them from having to deal with variable binding, contexts and use models à
la Kripke at the cost of using a large encoding. However we find scope safety
enforced at the type level to be a helpful guide when formalising complex
type theories. It helps us root out bugs related to fresh name generation,
name capture or conversion from de Bruijn levels to de Bruijns indices.

This paper's method really shines in a simply typed setting but it is not
limited to it: we have successfully used an analogue of our Semantics
framework to enforce scope safety when implementing the expected traversals
(renaming, substitution, untyped normalisation by evaluation and printing
with names) for the untyped λ-calculus (for which the notion of type safety
does not make sense) or Martin-Löf type theory. Apart from NbE (which relies
on a non strictly-positive datatype), all of these traversals are total.
Simulation and Fusion fundamental theorems akin to the ones proven in this
paper also hold true. The common structure across all these variations
suggests a possible generic scope safe treatment of syntaxes with binding.

This work is at the intersection of two traditions: the formal treatment
of programming languages and the implementation of embedded Domain Specific
Languages (eDSL)~\cite{hudak1996building} both require the designer to
deal with name binding and the associated notions of renaming and substitution
but also partial evaluation~\cite{danvy1999type}, or even printing when
emitting code or displaying information back to the user~\cite{wiedijk2012pollack}.
The mechanisation of a calculus in a \emph{meta language} can use either
a shallow or a deep embedding~\cite{svenningsson2013combining,gill2014domain}.

The well-scoped and well typed final encoding described by Carette, Kiselyov,
and Shan~(\citeyear{carette2009finally}) allows the mechanisation of a calculus in
Haskell or OCaml by representing terms as expressions built up from the
combinators provided by a ``Symantics''. The correctness of the encoding
relies on parametricity~\cite{reynolds1983types} and although there exists
an ongoing effort to internalise parametricity~\cite{bernardy2013type} in
Type Theory, this puts a formalisation effort out of the reach of all the
current interactive theorem provers.

Because of the strong restrictions on the structure our \AF{Model}s may have,
we cannot represent all the interesting traversals imaginable. Chapman and
Abel's work on normalisation by evaluation~(\citeyear{chapman2009type,abel2014normalization})
which decouples the description of the big-step algorithm and its termination
proof is for instance out of reach for our system. Indeed, in their development
the application combinator may \emph{restart} the computation by calling the
evaluator recursively whereas the \AF{Applicative} constraint we impose means
that we may only combine induction hypotheses.

McBride's original unpublished work~(\citeyear{mcbride2005type}) implemented
in Epigram~\cite{mcbride2004view} was inspired by Goguen and McKinna's
Candidates for Substitution~(\citeyear{goguen1997candidates}). It focuses on
renaming and substitution for the simply typed $λ$-calculus and was later
extended to a formalisation of System F~\cite{girard1972interpretation}
in Coq~\cite{Coq:manual} by Benton, Hur, Kennedy and McBride~(\citeyear{benton2012strongly}).
Benton et al. both implement a denotational semantics for their language
and prove the properties of their traversals. However both of these things
are done in an ad-hoc manner: the meaning function associated to their
denotational semantics is not defined in terms of the generic traversal
and the proofs are manually discharged one by one. They also choose to prove
the evaluation function correct by using propositional equality and assuming
function extensionality rather than resorting to the traditional Partial
Equivalence Relation approach we use.

\section{Conclusion}

We have explained how to make using an inductive family to only represent
the terms of an eDSL which are well-scoped and well typed by construction
more tractable. We proceeded by factoring out a common notion of \AR{Semantics}
encompassing a wide range of type and scope preserving traversals such as
renaming and substitution, which were already handled by the state of the
art, but also pretty printing, or various variations on normalisation by evaluation.
Our approach crucially relied on the careful distinction we made between
values in the environment and values in the model, as well as the slight
variation on the structure typical of Kripke-style models. Indeed, in our
formulation, the domain of a binder's interpretation is an environment
value rather than a model one.

We have then demonstrated that, having this shared structure, one could
further alleviate the implementer's pain by tackling the properties of
these \AR{Semantics} in a similarly abstract approach. We characterised,
using a first logical relation, the traversals which were producing
related outputs provided they were fed related inputs. A more involved
second logical relation gave us a general description of triples of
\AR{Fusable} semantics such that composing the two first ones would
yield an instance of the third one.

\acks
We would like to thank the anonymous
referees for their helpful comments. This work was supported by EPSRC
grant EP/M016951/1 and EP/K020218/1 and the European Research Council
under grant agreement N°320571. Data (Agda code) associated with research
published in this paper is available at the University of Strathclyde's
KnowledgeBase~\cite{repo}.
