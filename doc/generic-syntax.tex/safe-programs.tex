\chapter{Generic Scope Safe and Well Kinded Programs for Syntaxes}\label{chapter:generic-semantics}

The set of constraints we called a \AR{Semantics} in \cref{section:generic-semantics}
for the specific example of the simply typed λ-calculus could be divided in two groups:
the one arising from the fact that we need to be able to push environment values under
binders and the ones in one-to-one correspondence with constructors for the language.

Based on this observation, we can define a generic notion of semantics for all syntax
descriptions. It is once more parametrised by two (\AB{I}\AF{─Scoped}) families \AB{𝓥}
and \AB{𝓒} corresponding respectively to values associated to bound variables and
computations delivered by evaluating terms.

\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{semrec}

These two families have to abide by three constraints. First, values should be thinnable
so that we can push the evaluation environment under binders.

\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{thv}

Second, values should embed into computations for us to be able to return the value
associated to a variable in the environment as the result of its evaluation.

\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{var}

Third, we have a constraint similar to the one needed to define \AF{fold} in
\cref{section:data} (\cref{figure:datamu}). We should have an algebra taking
a term whose substructures have already been evaluated and returning a
computation for the overall term.

\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{alg}

To make formal this idea of ``hav[ing] already been evaluated'' we crucially use
the fact that the meaning of a description is defined in terms of a function
interpreting substructures which has the type (\AF{List} \AB{I} \AS{→} \AB{I}\AF{─Scoped}),
i.e. that gets access to the current scope but also the exact list of the newly
bound variables' kinds.

We define a function \AF{Kripke} by case analysis on the number of newly bound
variables. It is essentially a subcomputation waiting for a value associated to
each one of the fresh variables. If it's $0$ we expect the substructure to be a
computation corresponding to the result of the evaluation function's recursive
call; but if there are newly bound variables then we expect to have a function
space. In any context extension, it will take an environment of values for the
newly-bound variables and produce a computation corresponding to the evaluation
of the body of the binder.

\ExecuteMetaData[shared/Data/Environment.tex]{kripke}

%The name \AF{Kripke} comes from the connection with the interpretation of
%implication in Kripke models where if something holds in one world, it holds
%in all successive ones.

It is once more the case that the abstract notion of Semantics comes with a
fundamental lemma: all \AB{I} \AF{─Scoped} families \AB{𝓥} and \AB{𝓒} satisfying
the three criteria we have put forward give rise to an evaluation function.
We introduce a notion of computation \AF{\_─Comp} analogous to that of environments:
instead of associating values to variables, it associates computations to terms.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{comp}
\caption{\AF{\_─Comp}: Associating Computations to Terms}
\end{figure}

We can now define the type of the fundamental lemma (called \AF{sem}) which
takes a semantics and returns a function from environments to computations. It is
defined mutually with a function \AF{body} turning syntactic binders into
semantics binders: to each de Bruijn \AF{Scope} (i.e. a substructure in a potentially
extended context) it associates a \AF{Kripke} (i.e. a subcomputation expecting a
value for each newly bound variable).

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{semtype}
\caption{Statement of the Fundamental Lemma of \AR{Semantics}}
\end{figure}

The proof of \AF{sem} is straightforward now that we have clearly identified the
problem structure and the constraints we need to enforce. If the term considered
is a variable, we lookup the associated value in the evaluation environment and
turn it into a computation using \ARF{var}. If it is a non variable constructor
then we call \AF{fmap} to evaluate the substructures using \AF{body} and then
call the \ARF{alg}ebra to combine these results.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{semproof}
\caption{Proof of the Fundamental Lemma of \AR{Semantics} -- \AF{sem}}
\end{figure}

The auxiliary lemma \AF{body} distinguishes two cases. If no new variable has
been bound in the recursive substructure, it is a matter of calling \AF{sem}
recursively. Otherwise we are provided with a \AF{Thinning}, some additional
values and evaluate the substructure in the thinned and extended evaluation
environment thanks to a auxiliary function \AF{\_>>\_} which given two
environments {(\AB{Γ} \AR{─Env}) \AB{𝓥} \AB{Θ}} and {(\AB{Δ} \AR{─Env}) \AB{𝓥} \AB{Θ}}
produces an environment {((\AB{Γ} \AF{++} \AB{Δ}) \AR{─Env}) \AB{𝓥} \AB{Θ})}.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{bodyproof}
\caption{Proof of the Fundamental Lemma of \AR{Semantics} -- \AF{body}}
\end{figure}

Given that \AF{fmap} introduces one level of indirection between the recursive
calls and the subterms they are acting upon, the fact that our terms are indexed
by a \AF{Size} is once more crucial in getting the termination checker to see
that our proof is indeed well founded.
