\chapter{Generic Scope Safe and Well Kinded Programs for Syntaxes}\label{chapter:generic-semantics}

The set of constraints we called a \AR{Semantics} in
\cref{section:generic-semantics} for the specific example of the
simply typed λ-calculus could be divided in two groups: the one
arising from the fact that we need to be able to push environment
values under binders and the ones in one-to-one correspondence
with constructors for the language.

Based on this observation, we can define a generic notion of semantics
for all syntax descriptions. It is once more parametrised by two
{(\AB{I}\AF{─Scoped})} families \AB{𝓥} and \AB{𝓒} corresponding
respectively to values associated to bound variables and computations
delivered by evaluating terms.

{
\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{semrec}
\label{defn:Semantics}
}

These two families have to abide by three constraints. First, values
should be thinnable so that we can push the evaluation environment
under binders.

\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{thv}

Second, values should embed into computations for us to be able to
return the value associated to a variable in the environment as the
result of its evaluation.

\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{var}

Third, we have a constraint similar to the one needed to define \AF{fold} in
\cref{section:data} (\cref{figure:datamu}). We should have an algebra taking
a term whose substructures have already been evaluated and returning a
computation for the overall term.

\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{alg}

To make formal this idea of ``hav[ing] already been evaluated'' we crucially use
the fact that the meaning of a description is defined in terms of a function
interpreting substructures which has the type (\AF{List} \AB{I} \AS{→} \AB{I}\AF{─Scoped}),
i.e. that gets access to the current scope but also the exact list of the newly
bound variables' kinds.

We define a function \AF{Kripke} by case analysis on the number of newly bound
variables. It is essentially a subcomputation waiting for a value associated to
each one of the fresh variables. If it's $0$ we expect the substructure to be a
computation corresponding to the result of the evaluation function's recursive
call; but if there are newly bound variables then we expect to have a function
space. In any context extension, it will take an environment of values for the
newly-bound variables and produce a computation corresponding to the evaluation
of the body of the binder.

{
\ExecuteMetaData[shared/Data/Environment.tex]{kripke}
\label{defn:Kripke}
}

%The name \AF{Kripke} comes from the connection with the interpretation of
%implication in Kripke models where if something holds in one world, it holds
%in all successive ones.

It is once more the case that the abstract notion of Semantics comes with
a fundamental lemma: all \AB{I} \AF{─Scoped} families \AB{𝓥} and \AB{𝓒}
satisfying the three criteria we have put forward give rise to an evaluation
function. We introduce a notion of computation \AF{\_─Comp} analogous to
that of environments: instead of associating values to variables, it
associates computations to terms.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{comp}
\caption{\AF{\_─Comp}: Associating Computations to Terms}
\end{figure}

We can now define the type of the fundamental lemma (called \AF{semantics}) which
takes a semantics and returns a function from environments to computations. It is
defined mutually with a function \AF{body} turning syntactic binders into
semantics binders: to each de Bruijn \AF{Scope} (i.e. a substructure in a potentially
extended context) it associates a \AF{Kripke} (i.e. a subcomputation expecting a
value for each newly bound variable).

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{semtype}
\caption{Statement of the Fundamental Lemma of \AR{Semantics}\label{defn:semantics}}
\end{figure}

The proof of \AF{semantics} is straightforward now that we have clearly identified the
problem's structure and the constraints we need to enforce. If the term considered
is a variable, we lookup the associated value in the evaluation environment and
turn it into a computation using \ARF{var}. If it is a non variable constructor
then we call \AF{fmap} to evaluate the substructures using \AF{body} and then
call the \ARF{alg}ebra to combine these results.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{semproof}
\caption{Proof of the Fundamental Lemma of \AR{Semantics} -- \AF{semantics}}
\end{figure}

The auxiliary lemma \AF{body} distinguishes two cases. If no new variable has
been bound in the recursive substructure, it is a matter of calling \AF{semantics}
recursively. Otherwise we are provided with a \AF{Thinning}, some additional
values and evaluate the substructure in the thinned and extended evaluation
environment thanks to a auxiliary function \AF{\_>>\_} which given two
environments {(\AB{Γ} \AR{─Env}) \AB{𝓥} \AB{Θ}} and {(\AB{Δ} \AR{─Env}) \AB{𝓥} \AB{Θ}}
produces an environment {((\AB{Γ} \AF{++} \AB{Δ}) \AR{─Env}) \AB{𝓥} \AB{Θ})}.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{bodyproof}
\caption{Proof of the Fundamental Lemma of \AR{Semantics} -- \AF{body}\label{fig:genbody}}
\end{figure}

Given that \AF{fmap} introduces one level of indirection between the recursive
calls and the subterms they are acting upon, the fact that our terms are indexed
by a \AF{Size} is once more crucial in getting the termination checker to see
that our proof is indeed well founded.

Because most of our examples involve closed terms (for which we have
introduced a special notation in \cref{fig:closedtm}), we immediately
introduce \AF{closed}, a corollary of the fundamental lemma of semantics
for the special cases of closed terms in Figure~\ref{fig:closedsem}.
Given a \AR{Semantics} with value type \AB{𝓥} and computation type \AB{𝓒},
we can evaluate a closed term of type \AB{σ} and obtain a computation of
type {(\AB{𝓒} \AB{σ} \AIC{[]})} by kickstarting the evaluation with an
empty environment.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Semantics.tex]{closed}
\caption{Special Case: Fundamental Lemma of \AR{Semantics} for Closed Terms\label{fig:closedsem}}
\end{figure}

\section{Our First Generic Programs: Renaming and Substitution}\label{section:renandsub}

Similarly to \cref{sec:syntactic} renaming and substitutions can be defined generically
for all syntax descriptions.

\paragraph{Renaming} is a semantics with \AF{Var} as values and \AD{Tm} as computations.
The first two constraints on \AF{Var} described earlier are trivially satisfied. Observing
that renaming strictly respects the structure of the term it goes through, it makes
sense for the algebra to be implemented using \AF{fmap}. When dealing with the body
of a binder, we `reify' the \AF{Kripke} function by evaluating it in an extended
context and feeding it placeholder values corresponding to the extra variables
introduced by that context. This is reminiscent both of what we did in
\cref{sec:syntactic} and the definition of reification in the setting of normalisation
by evaluation (see e.g. Coquand's work~\citeyear{coquand2002formalised}).

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Semantics/Syntactic.tex]{renaming}
\caption{Renaming: A Generic Semantics for Syntaxes with Binding\label{fig:genrensem}}
\end{figure}

From this instance, we can derive the proof that all terms are \AF{Thinnable} as
a corollary of the fundamental lemma of \AR{Semantics}.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Semantics/Syntactic.tex]{thTm}
\caption{Corollary: Generic Thinning\label{fig:genren}}
\end{figure}

\paragraph{Substitution} is defined in a similar manner with \AD{Tm}
as both values and computations. Of the two constraints applying to
terms as values, the first one corresponds to renaming and the second
one is trivial. The algebra is once more defined by using \AF{fmap} and
reifying the bodies of binders. We can, once more, obtain parallel
substitution as a corollary of the fundamental lemma of \AR{Semantics}.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Semantics/Syntactic.tex]{substitution}
\ExecuteMetaData[generic-syntax.agda/Generic/Semantics/Syntactic.tex]{sub}
\caption{Generic Parallel Substitution for All Syntaxes with Binding\label{fig:gensub}}
\end{figure}

\paragraph{The reification process} mentioned in the definition of renaming
and substitution can be implemented generically for \semrec{} families
which have \AR{VarLike} values, i.e.  values which are thinnable and
such that we can craft placeholder values in non-empty contexts. It is
almost immediate that both \AD{Var} and \AD{Tm} are \AR{VarLike} (with
proofs \AF{vl\textasciicircum{}Var} and \AF{vl\textasciicircum{}Tm},
respectively).

\begin{figure}[h]
\ExecuteMetaData[shared/Data/Var/Varlike.tex]{varlike}
\caption{\AR{VarLike}: \AF{Thinnable} and with placeholder values\label{fig:VarLike}}
\end{figure}

\label{sec:varlike:base}
Given a proof that \AB{𝓥} is \AR{VarLike}, we can manufacture
several useful \AB{𝓥}-environments. We provide users with
\AF{base} of type {(\AB{Γ} \AR{─Env}) \AB{𝓥} \AB{Γ}},
\AF{fresh\textsuperscript{r}} of type
{(\AB{Γ} \AR{─Env}) \AB{𝓥} (\AB{Δ} \AF{++} \AB{Γ})}
and \AF{fresh\textsuperscript{l}} of type
{(\AB{Γ} \AR{─Env}) \AB{𝓥} (\AB{Γ} \AF{++} \AB{Δ})}
by combining the use of placeholder values and thinnings.
%
In the \AD{Var} case these very general definitions respectively specialise
to the identity renaming for a context \AB{Γ} and the injection of \AB{Γ}
fresh variables to the right or the left of an ambient context \AB{Δ}.
%
Similarly, in the \AD{Tm} case, we can show
{(\AF{base} \AF{vl\textasciicircum{}Tm})}
extensionally equal to the identity environment \AF{id\textasciicircum{}Tm}
given by {\AF{lookup} \AF{id\textasciicircum{}Tm} = \AIC{`var}},
which associates each variable to itself (seen as a term).

Using these definitions, we can then implement \AF{reify} as in
Figure~\ref{fig:kripkereify} turning \AF{Kripke} function spaces
from \AB{𝓥} to \AB{𝓒} into \AF{Scope}s of \AB{𝓒} computations.

\begin{figure}[h]
\ExecuteMetaData[shared/Data/Var/Varlike.tex]{reify}
\caption{Generic Reification thanks to \AR{VarLike} Values%
\label{fig:kripkereify}}
\end{figure}

We can now showcase other usages by providing a catalogue of generic programs
for syntaxes with binding.

\input{generic-syntax.tex/catalogue/printing}
\input{generic-syntax.tex/catalogue/normalising}
