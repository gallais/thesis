\chapter{Typechecking as a Semantics}

In the previous chapter we have seen various generic semantics one may be interested in
when working on a deeply embedded language: renaming, substitution, desugaring,
evaluation, and printing with names. All of these fit neatly in the \AR{Semantics}
framework. Now we wish to study a specific language in particular and see how we can
take advantage of the same framework to structure language-specific traversals.

\section{An Algebraic Approach to Typechecking}\label{section:typechecking}

Following Atkey~\citeyear{atkey2015algebraic}, we can consider type checking
and type inference as a possible semantics for a bi-directional language
(\cite{pierce2000local}). We represent the raw syntax of a simply typed bi-directional
calculus as a bi-sorted language using a notion of \AD{Mode} to distinguish between
terms for which we will be able to \AIC{Infer} the type and the ones for which we will
have to \AIC{Check} a type candidate.

Following traditional presentations, eliminators give rise to \AIC{Infer}rable
terms under the condition that the term they are eliminating is also \AIC{Infer}rable
and the other arguments are \AIC{Check}able whilst constructors are always \AIC{Check}able.
Two extra constructors allow changes of direction: \AIC{Cut} annotates a \AIC{Check}able
term with its type thus making it \AIC{Infer}rable whilst \AIC{Emb} embeds
\AIC{Infer}rables into \AIC{Check}ables.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{type}
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{constructors}
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{mode}
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{bidirectional}
\caption{A Bidirectional Simply Typed Language}
\end{figure}

Both the values and computations will be constant in the scope. The values stored
in the environment will be \AD{Type} information for bound variables. Instead of
considering that we get a type no matter what the \AD{Mode} of the variable is,
we enforce the fact that all variables need to be \AIC{Infer}rable.

\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{varmode}

In contrast, the generated computations will, depending on the mode, either take a
type candidate and \AIC{Check} it is valid or \AIC{Infer} a type for their argument.
These computations are always potentially failing so we use the \AD{Maybe} monad.

\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{typemode}

Before defining typechecking as a \AR{Semantics}.

\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{arrow}
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{equal}

Equipped with these combinators, we can define the two most interesting cases
as top-level combinators: application and $\lambda$-abstraction.

When facing an application: infer the type of the function, make sure it is an
arrow type, check the argument at the domain's type and return the codomain.

\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{app}

For a $\lambda$-abstraction: check the input type is an arrow type and check
the body at the codomain type in the extended environment where the newly-bound
variable has the domain's type.

\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{lam}

We can now define typechecking itself. Because values are constant in the scope,
the \ARF{th\textasciicircum{}ùì•} constraint is trivial. The \ARF{var} constraint
is also easy: values correspond to \AIC{Infer}rable terms so we can simply return
the type looked up in the environment. The algebra describes the algorithm by pieces.
We have already handled application and $\lambda$-abstraction, a cut always comes with
a type candidate against which to check the term  and to be returned in case of
success (\AF{\_<\$\_} takes an \AB{A} and a {\AD{Maybe} \AB{B}} and returns
a {\AD{Maybe} \AB{A}} which has the same structure as its second argument).
Finally, the change of direction from \AIC{Infer}rable to \AIC{Check}able is successful
when the inferred type is equal to the expected one.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{typecheck}
\caption{Typechecking as a \AR{Semantics}}
\end{figure}

From this we can derive our \AF{type-}(\AIC{Infer}/\AIC{Check}) function which takes
a closed term and computes either an inferred type or a validation function for a
type candidate. We make use of the special case of \AF{semantics} for closed term
introduced in \cref{fig:closedsem}.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{typefun}
\caption{Type Inference and Type Checking as Mode-indexed Semantics\label{fig:typeinfersem}}
\end{figure}

We can run this typechecking function on an example and verify that we do get the type
we expect.

\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{example}

We have demonstrated how to define a bidirectional typechecker for this simple language
by leveraging the \AF{Semantics} framework. However the output of this function is not
very informative. We can do better: instead of simply generating a type or checking that
a candidate will do, we can use our \AD{Desc}riptions to describe a language of evidence
and generate not only an expression's type but also a well scoped and well typed term of
that type.

\section{An Algebraic Approach to Elaboration}

We use \AF{STLC} (defined in \cref{fig:descstlc}) as our internal language. That is to
say that starting from a \AF{Lang} term, the typechecking process should generate an
\AF{STLC} term.

Before we can jump right in, we need to set the stage: a \AR{Semantics} for a \AF{Lang}
term will involve ({\AD{Mode} \AF{‚îÄScoped}}) notions of values and computations but an
\AF{STLC} term is ({\AD{Type} \AF{‚îÄScoped}}). We first introduce a \AF{Typing} associating
types to each of the modes in scope, together with \AF{fromTyping} extracting the context
thus defined.

\begin{figure}[h]
\begin{minipage}{0.4\textwidth}
  \ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{typing}
\end{minipage}
\begin{minipage}{0.6\textwidth}
  \ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{fromtyping}
\end{minipage}
\end{figure}

We can then explain what it means for elaboration to target \AB{T} a
({\AD{Type} \AF{‚îÄScoped}}) at a type \AB{œÉ}: provided a list of modes and a corresponding
typing, we should get a \AB{T} of type \AB{œÉ} in the context induced by that \AF{Typing}.

\ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{elab}

In particular, we declare that environment values are functions which, provided any
typing of the scope of modes they live in, return a type together with a variable of
that type in the context induced by that typing. We once more limit environment values
to the \AIC{Infer} mode only.

\ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{varmode}

The computations are a bit more tricky. On the one hand, if we are in checking mode
then we expect that for any typing of the scope of modes and any type candidate we
can \AD{Maybe} return a term at that type in the induced context. On the other hand,
in the inference mode we expect that given any typing of the scope, we can \AD{Maybe}
return a type together with a term at that type in the induced context.

\ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{typemode}

Because we are now writing a typechecker which returns evidence of its claims, we need
more informative variants of the equality and \AF{isArrow} checks. In the equality
checking case, we only care about the successful path and happily return \AIC{nothing}
when failing. Agda's support for (dependent!) \AK{do}-notations makes writing the check
really easy. For the arrow type, we introduce a family \AD{Arrow} constraining the
shape of its index to be an arrow type and redefine \AF{isArrow} as a view targetting
this inductive family (\cite{Wadler:1987:VWP:41625.41653}).

\begin{figure}[h]
\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{equal}
\end{minipage}
\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{arrow}
\end{minipage}
\end{figure}

\ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{app}
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{lam}
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{emb}
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{elaborate}
