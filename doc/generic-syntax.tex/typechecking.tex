\chapter{Typechecking as a Semantics}

In the previous chapter we have seen various generic semantics one may be interested in
when working on a deeply embedded language: renaming, substitution, desugaring,
evaluation, and printing with names. All of these fit neatly in the \AR{Semantics}
framework. Now we wish to study a specific language in particular and see how we can
take advantage of the same framework to structure language-specific traversals.

\section{An Algebraic Approach to Typechecking}\label{section:typechecking}

Recalling Atkey (\citeyear{atkey2015algebraic}), we can consider type checking
and type inference as a possible semantics for a bi-directional language
(\cite{pierce2000local}). We represent the raw syntax of a simply typed bi-directional
calculus as a bi-sorted language using a notion of \AD{Mode} to distinguish between
terms for which we will be able to \AIC{Infer} the type and the ones for which we will
have to \AIC{Check} a type candidate. Cuts will be \AD{Type}-annotated so we also
introduce the set of types at hand.

\begin{figure}[h]
\begin{minipage}{0.5\textwidth}
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{mode}
\end{minipage}\begin{minipage}{0.5\textwidth}
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{type}
\end{minipage}
\caption{Modes and Types}
\end{figure}

We define the language of ({\AD{Mode} \AF{â”€Scoped}}) terms using our language of
descriptions. We start once more with \AD{LangC}, the language's constructors,
and dispatch over such constructors using a pattern-matching lambda. Following
traditional presentations, eliminators give rise to \AIC{Infer}rable terms under
the condition that the term they are eliminating is also \AIC{Infer}rable and
the other arguments are \AIC{Check}able whilst constructors and their arguments
are always \AIC{Check}able. Two extra constructors allow changes of direction:
\AIC{Cut} annotates a checkable term with its \AD{Type} thus making it inferrable
whilst \AIC{Emb} embeds inferrables into checkables.

\begin{figure}[h]
\begin{minipage}{0.4\textwidth}
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{constructors}
\end{minipage}\begin{minipage}{0.6\textwidth}
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{bidirectional}
\end{minipage}
\caption{A Bidirectional Simply Typed Language}
\end{figure}

Both the values and computations will be constant in the scope. The values stored
in the environment will be \AD{Type} information for bound variables. Instead of
considering that we get a type no matter what the \AD{Mode} of the variable is,
we enforce the fact that all variables need to be \AIC{Infer}rable.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{varmode}
\caption{Values as Type Assignments for Variables}
\end{figure}

In contrast, the generated computations will, depending on the mode, either take a
type candidate and \AIC{Check} it is valid or \AIC{Infer} a type for their argument.
These computations are always potentially failing so we use the \AD{Maybe} monad.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{typemode}
\caption{Computations as \AD{Mode}-indexed Type Checking or Inference}
\end{figure}

Before defining typechecking as a \AR{Semantics} we need to introduce two simple
checks: a first function checking that two types are equal and a second making
sure its input is a function type and returning its domain and codomain.

\begin{figure}[h]
\begin{minipage}{0.5\textwidth}
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{equal}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{arrow}
\end{minipage}
\end{figure}

Equipped with these combinators, we can define the two most interesting cases
as top-level combinators: application and $\lambda$-abstraction. When dealing
with an application: infer the type of the function, make sure it is an
arrow type, check the argument at the domain's type and return the codomain
(\AF{\_<\$\_} takes an \AB{A} and a {\AD{Maybe} \AB{B}} and returns
a {\AD{Maybe} \AB{A}} which has the same structure as its second argument).

\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{app}

For a $\lambda$-abstraction: check the input type is an arrow type and check
the body at the codomain type in the extended environment where the newly-bound
variable is \AIC{Infer}rable and is assigned the type of the domain.

\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{lam}

We can now define typechecking itself. Because values are constant in the scope,
the \ARF{th\textasciicircum{}ð“¥} constraint is trivial. The \ARF{var} constraint
is also easy: values correspond to \AIC{Infer}rable terms so we can simply return
the type looked up in the environment. The algebra describes the algorithm by pieces.
We have already handled application and $\lambda$-abstraction, a cut always comes with
a type candidate against which to check the term  and to be returned in case of
success.
Finally, the change of direction from \AIC{Infer}rable to \AIC{Check}able is successful
when the inferred type is equal to the expected one.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{typecheck}
\caption{Typechecking as a \AR{Semantics}}
\end{figure}

From this we can derive our \AF{type-}(\AIC{Infer}/\AIC{Check}) function which takes
a closed term and computes either an inferred type or a validation function for a
type candidate. We make use of the special case of \AF{semantics} for closed term
introduced in \cref{fig:closedsem}.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{typefun}
\caption{Type Inference and Type Checking as Mode-indexed Semantics\label{fig:typeinfersem}}
\end{figure}

We can run this typechecking function on an example and verify that we do get the type
we expect.

\ExecuteMetaData[generic-syntax.agda/Generic/Examples/TypeChecking.tex]{example}

We have demonstrated how to define a bidirectional typechecker for this simple language
by leveraging the \AF{Semantics} framework. However the output of this function is not
very informative. We can do better.

\section{An Algebraic Approach to Elaboration}

Instead of simply generating a type or checking that a candidate will do, we can use our
\AD{Desc}riptions to describe not only the source language but also a language of evidence.
During typechecking we generate at the same time an expression's type and a well scoped and
well typed term of that type. We use \AF{STLC} (defined in \cref{fig:descstlc}) as our
\emph{internal} language. That is to say that starting from a \AF{Lang} term, the typechecking
process should generate an \AF{STLC} term.

Before we can jump right in, we need to set the stage: a \AR{Semantics} for a \AF{Lang}
term will involve ({\AD{Mode} \AF{â”€Scoped}}) notions of values and computations but an
\AF{STLC} term is ({\AD{Type} \AF{â”€Scoped}}). We first introduce a \AF{Typing} associating
types to each of the modes in scope, together with \AF{fromTyping} extracting the context
thus defined.

\begin{figure}[h]
\begin{minipage}{0.4\textwidth}
  \ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{typing}
\end{minipage}
\begin{minipage}{0.6\textwidth}
  \ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{fromtyping}
\end{minipage}
\caption{Typing: From Contexts of \AD{Mode}s to Contexts of \AD{Type}s\label{fig:typingmodes}}
\end{figure}

We can then explain what it means for elaboration to target \AB{T} a
({\AD{Type} \AF{â”€Scoped}}) at a type \AB{Ïƒ}: provided a list of modes and a corresponding
typing, we should get a \AB{T} of type \AB{Ïƒ} in the context induced by that \AF{Typing}.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{elab}
\caption{Elaboration of a Scoped Family}
\end{figure}

In particular, our environment values are elaboration functions targetting \AD{Var}. We
expect all values to be in scope i.e. provided any typing of the scope of modes, we are
guaranteed to return a type together with a variable of that type in the context induced
by the typing. We once more limit environment values to the \AIC{Infer} mode only.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{varmode}
\caption{Values as Variables and Inference Functions\label{fig:elabvalues}}
\end{figure}

The computations are a bit more tricky. On the one hand, if we are in checking mode
then we expect that for any typing of the scope of modes and any type candidate we
can \AD{Maybe} return a term at that type in the induced context. On the other hand,
in the inference mode we expect that given any typing of the scope, we can \AD{Maybe}
return a type together with a term at that type in the induced context.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{typemode}
\caption{Computations as \AD{Mode}-indexed Elaboration Functions\label{fig:elabcomputations}}
\end{figure}

Because we are now writing a typechecker which returns evidence of its claims, we need
more informative variants of the equality and \AF{isArrow} checks. In the equality
checking case we want to get a proof of propositional equality but we only care
about the successful path and will happily return \AIC{nothing} when failing.
Agda's support for (dependent!) \AK{do}-notations makes writing the check
really easy. For the arrow type, we introduce a family \AD{Arrow} constraining the
shape of its index to be an arrow type and redefine \AF{isArrow} as a view targetting
this inductive family (\cite{Wadler:1987:VWP:41625.41653}).

\begin{figure}[h]
\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{equal}
\end{minipage}
\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{arrow}
\end{minipage}
\caption{Informative Equality Check and Arrow View\label{fig:informativecheck}}
\end{figure}

We now have all the basic pieces and can start writing elaboration code. We
once more start by dealing with each constructor in isolation before putting
everything together to get a \AR{Semantics}. These steps are very similar to
the ones in the previous section.

In the application case, we start by elaborating the function and we get its
type together with an internal term. We then check that the inferred type is
indeed an \AD{Arrow} and elaborate the argument using the corresponding domain.
We conclude by returning the codomain together with the internal function
applied to the internal argument.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{app}
\caption{Elaboration of Applications}
\end{figure}

The $\lambda$-abstraction case, we start by checking that the type candidate
is an \AD{Arrow}. We can then elaborate the body of the lambda in a context
extended with one \AIC{Infer} variable assigned an inference function thanks
to the auxiliary function \AF{var0}. From this we get an internal term corresponding
to the body of the $\lambda$-abstraction and conclude by returning it wrapped
in a \AIC{`lam} constructor.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{lam}
\caption{Elaboration of Lambda-Abstraction}
\end{figure}

This time we also stop to consider the semantical counterpart of the change of
direction \AIC{Emb} which turns an inferrable into a checkable. We not only want
to check that the inferred type and the type candidate are equal: we need to cast
the internal term labelled with the inferred type to match the type candidate.
Luckily, Agda's dependent \AK{do}-notations make once again our job easy: when
we make the pattern \AIC{refl} explicit, the equality holds in the rest of the block.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{emb}
\caption{Elaboration of Embedding}
\end{figure}

We have almost everything we need to define elaboration as a semantics. Discharging
the \ARF{th\textasciicircum{}ð“¥} constraint is a bit laborious and the proof doesn't
yield any additional insight so we leave it out here. The semantical counterpart of
variables (\ARF{var}) is fairly straightforward: provided a \AF{Typing}, we run the
inference and touch it up to return a term rather than a mere variable. Finally we
define the algebra (\ARF{alg}) by pattern-matching on the constructor and using our
previous combinators; the only case left is \AIC{Cut} whose \AD{Type} annotation
provides precisely the piece of information we need.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Examples/Elaboration.tex]{elaborate}
\caption{Elaboration as a Semantics}
\end{figure}
