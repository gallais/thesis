\chapter{Building Generic Proofs about Generic Programs}

We have already shown in \cref{sec:simulationrel,sec:fusionrel} that, for the
simply typed $\lambda$-calculus, introducing an abstract notion of Semantics
not only reveals the shared structure of common traversals, it also allows
us to give abstract proof frameworks for simulation or fusion lemmas. These
ideas naturally extend to our generic presentation of semantics for all syntaxes.

\section{Additional Relation Transformers}

During our exploration of generic proofs about the behaviour of \AR{Semantics}
for a concrete object language, we have introduced a notion \AR{Rel} of
relations as well as a relation transformer for environments
(cf. \cref{sec:relation-transformers}). Working on a universe of syntaxes,
we are going to need to define additional relators.

\paragraph{Kripke relator}
The Kripke relator is a generalisation of the ad-hoc definition introduced
in \cref{fig:relationalkripke}. We assume that we have two types of values
\AB{ùì•·¥¨} and \AB{ùì•·¥Æ}
as well as a relation \AB{ùì•·¥ø} for pairs of such values, and two types
of computations \AB{ùìí·¥¨} and \AB{ùìí·¥Æ} whose notion of relatedness is
given by \AB{ùìí·¥ø}. We can define
\AF{Kripke·¥ø} relating Kripke functions of type
{(\AF{Kripke} \AB{ùì•·¥¨} \AB{ùìí·¥¨})} and {(\AF{Kripke} \AB{ùì•·¥Æ} \AB{ùìí·¥Æ})}
respectively by stating that they send related inputs
to related outputs. We use the relation transformer \AF{All} defined
in the previous paragraph.

\begin{figure}[h]
 \ExecuteMetaData[shared/Data/Var/Varlike.tex]{kripkeR}
\caption{Relational Kripke Function Spaces: From Related Inputs to Related Outputs\label{fig:Kripke-rel}}
\end{figure}

\paragraph{Desc relator}
The relator (\AF{‚ü¶} \AB{d} \AF{‚üß·¥ø}) is a relation transformer which characterises
structurally equal layers such that their substructures are themselves related
by the relation it is passed as an argument. It inherits a lot of its relational
arguments' properties: whenever \AB{R} is reflexive (respectively symmetric or
transitive) so is {(\AF{‚ü¶} \AB{d} \AF{‚üß·¥ø} \AB{R})}.\label{lem:zipstable}

It is defined by induction on the description and case analysis on the two
layers which are meant to be equal:
\begin{itemize}
  \item In the stop token case \AIC{`‚àé} \AB{i}, the two layers are considered to
    be trivially equal (i.e. the constraint generated is the unit type)
  \item When facing a recursive position {\AIC{`X} \AB{$\Delta$} \AB{j} \AB{d}}, we
    demand that the two substructures are related by {\AB{R} \AB{$\Delta$} \AB{j}}
    and that the rest of the layers are related by (\AF{‚ü¶} \AB{d} \AF{‚üß·¥ø} \AB{R})
  \item Two nodes of type {\AIC{`$\sigma$} \AB{A} \AB{d}} will
    be related if they both carry the same payload \AB{a} of type \AB{A} and if
    the rest of the layers are related by (\AF{‚ü¶} \AB{d} \AB{a} \AF{‚üß·¥ø} \AB{R})
\end{itemize}

\begin{figure}[h]
 \ExecuteMetaData[generic-syntax.agda/Generic/Relator.tex]{ziptype}
\caption{Relator: Characterising Structurally Equal Values with Related Substructures\label{fig:zip-rel}}
\end{figure}

If we were to take a fixpoint of \AF{‚ü¶\_‚üß·¥ø}, we could obtain a structural
notion of equality for terms which we could prove equivalent to propositional
equality. Although interesting in its own right, this section will focus
on more advanced use-cases.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SIMULATION

\input{generic-syntax.tex/proofs/simulation.tex}
\input{generic-syntax.tex/proofs/fusion.tex}

