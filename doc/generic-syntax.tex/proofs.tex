

\chapter{Building Generic Proofs about Generic Programs}

We have already shown in \cref{sec:simulationrel,sec:fusionrel} that, for the
simply typed $\lambda$-calculus, introducing an abstract notion of Semantics
not only reveals the shared structure of common traversals, it also allows
us to give abstract proof frameworks for simulation or fusion lemmas. These
ideas naturally extend to our generic presentation of semantics for all syntaxes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% RELATORS

\section{Relations and Relation Transformers}

In our exploration of generic proofs about the behaviour of various \AR{Semantics},
we are going to need to manipulate relations between distinct notions of values or
computations. In this section, we introduce the notion of relation we are going to
use as well as these two key relation transformers.

In Section~\ref{sec:genenvironment} we introduced a generic notion of well typed
and scoped environment as a function from variables to values. Its formal definition
is given in Figure~\ref{fig:environment} as a record type. This record wrapper helps
Agda's type inference reconstruct the type family of values whenever it is passed an
environment.

For the same reason, we will use a record wrapper for the concrete implementation of
our notion of relation over (I \AF{─Scoped}) families. A \AR{Rel}ation between two
such families \AB{T} and \AB{U} is a function which to any \AB{σ} and \AB{Γ}
associates a relation between (\AB{T} \AB{σ} \AB{Γ}) and (\AB{U} \AB{σ} \AB{Γ}).
Our first example of such a relation is \AF{Eqᴿ} the equality relation between
an (\AB{I}\AF{─Scoped}) family \AB{T} and itself.

\begin{figure}[h]
\begin{minipage}[t]{0.65\textwidth}
  \ExecuteMetaData[shared/Data/Relation.tex]{rel}
\end{minipage}
\begin{minipage}[t]{0.25\textwidth}
  \ExecuteMetaData[shared/Data/Relation.tex]{eqR}
\end{minipage}
\caption{Relation Between \AB{I}\AF{─Scoped} Families and Equality Example\label{ex:fam-eq}}
\label{fig:reldef}
\end{figure}

Once we know what relations are, we are going to have to lift relations on values
and computations to relations on environments, \AF{Kripke} function spaces or
on \AB{d}-shaped terms whose subterms have been evaluated already.
This is what the rest of this section focuses on.

\paragraph{Environment relator}
Provided a relation \AB{𝓥ᴿ} for notions of values \AB{𝓥ᴬ} and \AB{𝓥ᴮ}, by
pointwise lifting we can define a relation {(\AR{All} \AB{𝓥ᴿ} \AB{Γ})} on
\AB{Γ}-environments of values \AB{𝓥ᴬ} and \AB{𝓥ᴮ} respectively. We once more
use a record wrapper simply to facilitate Agda's job when reconstructing
implicit arguments.

\begin{figure}[h]
  \ExecuteMetaData[shared/Data/Relation.tex]{all}
\caption{Relating \AB{Γ}-Environments in a Pointwise Manner\label{defn:Env-rel}}
\end{figure}

The first example of two environment being related is \AF{reflᴿ} that, to any
environment \AB{ρ} associates a trivial proof of the statement
{(\AR{All} \AF{Eqᴿ} \AB{Γ} \AB{ρ} \AB{ρ})}.
The combinators we introduced in Figure~\ref{fig:baseenv} to build environments
(\AF{ε}, \AF{\_∙\_}, etc.) have natural relational counterparts. We reuse the same
names for them, simply appending an \AF{ᴿ} suffix.

\paragraph{Kripke relator}
We assume that we have two types of values \AB{𝓥ᴬ} and \AB{𝓥ᴮ}
as well as a relation \AB{𝓥ᴿ} for pairs of such values, and two types of computations
\AB{𝓒ᴬ} and \AB{𝓒ᴮ} whose notion of relatedness is given by \AB{𝓒ᴿ}. We can define
\AF{Kripkeᴿ} relating Kripke functions of type
{(\AF{Kripke} \AB{𝓥ᴬ} \AB{𝓒ᴬ})} and {(\AF{Kripke} \AB{𝓥ᴮ} \AB{𝓒ᴮ})}
respectively by stating that they send related inputs
to related outputs. We use the relation transformer \AF{All} defined in the previous
paragraph.

\begin{figure}[h]
 \ExecuteMetaData[shared/Data/Var/Varlike.tex]{kripkeR}
\caption{Relational Kripke Function Spaces: From Related Inputs to Related Outputs\label{fig:Kripke-rel}}
\end{figure}

\paragraph{Desc relator}
The relator (\AF{⟦} \AB{d} \AF{⟧ᴿ}) is a relation transformer which characterises
structurally equal layers such that their substructures are themselves related
by the relation it is passed as an argument. It inherits a lot of its relational
arguments' properties: whenever \AB{R} is reflexive (respectively symmetric or
transitive) so is {(\AF{⟦} \AB{d} \AF{⟧ᴿ} \AB{R})}.\label{lem:zipstable}

It is defined by induction on the description and case analysis on the two
layers which are meant to be equal:
\begin{itemize}
  \item In the stop token case \AIC{`∎} \AB{i}, the two layers are considered to
    be trivially equal (i.e. the constraint generated is the unit type)
  \item When facing a recursive position {\AIC{`X} \AB{$\Delta$} \AB{j} \AB{d}}, we
    demand that the two substructures are related by {\AB{R} \AB{$\Delta$} \AB{j}}
    and that the rest of the layers are related by (\AF{⟦} \AB{d} \AF{⟧ᴿ} \AB{R})
  \item Two nodes of type {\AIC{`$\sigma$} \AB{A} \AB{d}} will
    be related if they both carry the same payload \AB{a} of type \AB{A} and if
    the rest of the layers are related by (\AF{⟦} \AB{d} \AB{a} \AF{⟧ᴿ} \AB{R})
\end{itemize}

\begin{figure}[h]
 \ExecuteMetaData[generic-syntax.agda/Generic/Relator.tex]{ziptype}
\caption{Relator: Characterising Structurally Equal Values with Related Substructures\label{fig:zip-rel}}
\end{figure}

If we were to take a fixpoint of \AF{⟦\_⟧ᴿ}, we could obtain a structural
notion of equality for terms which we could prove equivalent to propositional
equality. Although interesting in its own right, this section will focus
on more advanced use-cases.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SIMULATION

\input{generic-syntax.tex/proofs/simulation.tex}

\section{Fusion Lemma}\label{section:fusion}

Results that can be reformulated as the ability to fuse two traversals
obtained as \AR{Semantics} into one abound. When claiming that \AF{Tm} is
a Functor, we have to prove that two successive renamings can be fused into
a single renaming where the \AF{Thinning}s have been composed. Similarly,
demonstrating that \AF{Tm} is a relative Monad (\cite{JFR4389}) implies proving
that two consecutive substitutions can be merged into a single one whose
environment is the first one, where the second one has been applied in a
pointwise manner. The \emph{Substitution Lemma} central
to most model constructions (see for instance~\cite{mitchell1991kripke}) states
that a syntactic substitution followed by the evaluation of the resulting term
into the model is equivalent to the evaluation of the original term with an
environment corresponding to the evaluated substitution.

A direct application of these results is our (to be published) entry to the
POPLMark Reloaded challenge (\citeyear{poplmarkreloaded}). By using a \AD{Desc}-based
representation of intrinsically well typed and well scoped terms we directly inherit
not only renaming and substitution but also all four fusion lemmas as corollaries
of our generic results. This allows us to remove the usual boilerplate
and go straight to the point.
As all of these statements have precisely the same structure, we can
once more devise a framework which will, provided that its constraints are
satisfied, prove a generic fusion lemma.

Fusion is more involved than simulation so we will step through
each one of the constraints individually, trying to give the reader an intuition
for why they are shaped the way they are.


\subsection{The Fusion Constraints}

The notion of fusion is defined for a triple of \AR{Semantics}; each \AB{𝓢ⁱ}
being defined for values in \AB{𝓥ⁱ} and computations in \AB{𝓒ⁱ}. The
fundamental lemma associated to such a set of constraints will state that
running \AB{𝓢ᴮ} after \AB{𝓢ᴬ} is equivalent to running \AB{𝓢ᴬᴮ} only.

The definition of fusion is parametrised by three relations: \AB{𝓔ᴿ} relates
triples of environments of values in {(\AB{Γ} \AR{─Env}) \AB{𝓥ᴬ} \AB{Δ}},
{(\AB{Δ} \AR{─Env}) \AB{𝓥ᴮ} \AB{Θ}} and {(\AB{Γ} \AR{─Env}) \AB{𝓥ᴬᴮ} \AB{Θ}}
respectively; \AB{𝓥ᴿ} relates pairs of values \AB{𝓥ᴮ} and \AB{𝓥ᴬᴮ};
and \AB{𝓒ᴿ}, our notion of equivalence for evaluation results, relates pairs
of computation in \AB{𝓒ᴮ} and \AB{𝓒ᴬᴮ}.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{fusionrec}

The first obstacle we face is the formal definition of ``running \AB{𝓢ᴮ}
after \AB{𝓢ᴬ}'': for this statement to make sense, the result of running
\AB{𝓢ᴬ} ought to be a term. Or rather, we ought to be able to extract a
term from a \AB{𝓒ᴬ}. Hence the first constraint: the existence of a
\ARF{reifyᴬ} function, which we supply as a field of the record \AR{Fusion}.
When dealing with syntactic semantics such as renaming or substitution
this function will be the identity. Nothing prevents proofs, such as the
idempotence of NbE, which use a bona fide reification function that extracts
terms from model values.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{reify}

Then, we have to think about what happens when going under a binder: \AB{𝓢ᴬ}
will produce a \AF{Kripke} function space where a syntactic value is required.
Provided that \AB{𝓥ᴬ} is \AR{VarLike}, we can make use of \AF{reify} to get a
\AF{Scope} back. Hence the second constraint.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{vlV}

We can combine these two functions to define the reification procedure we will
use in practice when facing Kripke function spaces: \AF{quoteᴬ} which takes such
a function and returns a term by first feeding placeholder values to the Kripke
function space and getting a \AB{𝓒ᴬ} back and then reifying it thanks to \ARF{reifyᴬ}.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{quote}

Still thinking about going under binders: if three evaluation environments \AB{ρᴬ} of
type {(\AB{Γ} \AR{─Env}) \AB{𝓥ᴬ} \AB{Δ}}, \AB{𝓥ᴮ} in {(\AB{Δ} \AR{─Env}) \AB{𝓥ᴮ} \AB{Θ}},
and \AB{ρᴬᴮ} in {(\AB{Γ} \AR{─Env}) \AB{𝓥ᴬᴮ} \AB{Θ}} are related by \AB{𝓔ᴿ} and we are
given a thinning \AB{ρ} from \AB{Θ} to \AB{Ω} then \AB{ρᴬ}, the thinned \AB{𝓥ᴮ} and the
thinned \AB{ρᴬᴮ} should still be related.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{thV}

Remembering that \AF{\_>>\_} is used in the definition of \AF{body} (cf. \cref{fig:genbody})
to combine two disjoint environments {(\AB{Γ} \AR{─Env}) \AB{𝓥} \AB{Θ}} and
{(\AB{Δ} \AR{─Env}) \AB{𝓥} \AB{Θ}} into one of type
{((\AB{Γ} \AF{++} \AB{Δ}) \AR{─Env}) \AB{𝓥} \AB{Θ})}, we mechanically need a
constraint stating that \AF{\_>>\_} is compatible with \AB{𝓔ᴿ}. We demand
as an extra precondition that the values \AB{ρᴮ} and \AB{ρᴬᴮ} are extended
with are related in a pointwise manner according to \AB{𝓥ᴿ}. Lastly, for all
the types to match up, \AB{ρᴬ} has to be extended with placeholder variables
which we can do thanks to the \AR{VarLike} constraint \ARF{vl\textasciicircum{}𝓥ᴬ}.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{appendR}

We finally arrive at the constraints focusing on the semantical counterparts
of the terms' constructors. In order to have readable type we introduce an
auxiliary definition \AF{𝓡}. Just like in \cref{sec:fusionrel}, it relates at
a given type a term and three environments by stating that sequentially evaluating
the term in the first and then the second environment on the one hand and directly
evaluating the term in the third environment on the other yields related computations.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{crel}

As one would expect, the \ARF{varᴿ} constraint states that from related environments
the two evaluation processes described by \AF{𝓡} yield related outputs.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{varR}

The case of the algebra follows a similar idea albeit being more complex. It states
that we should be able to prove that a \AIC{`con}-headed term's evaluations are related
according to \AF{𝓡} provided that the evaluation of the constructor's body one way or
the other yields structurally similar results (hence the use of the ({\AF{Zip} \AB{d}})
relation transformer defined in \cref{def:zipd}) where the relational Kripke function
space relates the semantical objects one can find in place of the subterms.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{algR}

\subsection{Fundamental Lemma of Fusion}

This set of constraint is enough to prove a fundamental lemma of \AR{Fusion} stating
that from a triple of related environments, one gets a pair of related computations:
the composition of \AB{𝓢ᴬ} and \AB{𝓢ᴮ} on one hand and \AB{𝓢ᴬᴮ} on the other.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{fusiontype}
\caption{Statement of the Fundamental Lemma of Fusion\label{fig:fusiontype}}
\end{figure}

This lemma is once again proven mutually with its counterpart for \AR{Semantics}'
\AF{body}'s action on \AR{Scope}s: given related environments and a scope, the
evaluation of the recursive positions using \AB{𝓢ᴬ} followed by their reification
and their evaluation in \AB{𝓢ᴮ} should yield a piece of data \emph{structurally}
equal to the one obtained by using \AB{𝓢ᴬᴮ} instead where the values replacing
the recursive substructures are \AF{Kripkeᴿ}-related.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{bodytype}
\caption{Statement of the Fundamental Lemma of Fusion for Bodies\label{fig:fusiontype}}
\end{figure}

The proofs involve two functions we have not mentioned before: \AF{zip} maps a proof that
a property holds for any recursive substructure over the arguments of constructor to
obtain a \AF{Zip} object. The proof we obtain does not exactly match the premise in
\ARF{algᴿ}; we need to adjust it by rewriting an \AF{fmap}-fusion equality called
\AF{fmap²}.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{fusioncode}
\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{bodycode}
\caption{Proof of the Fundamental Lemma of Fusion}
\end{figure}

\subsection{Applications}

A direct consequence of this result is the four lemmas collectively stating
that any pair of renamings and / or substitutions can be fused together to
produce either a renaming (in the renaming-renaming interaction case) or a
substitution (in all the other cases).

One such example is the fusion of substitution followed by renaming into a
single substitution where the renaming has been applied to the environment.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Fusion/Syntactic.tex]{subren}
\caption{Generic Substitution-Renaming Fusion Principle}
\end{figure}

All four lemmas are proved in rapid succession by instantiating the \AR{Fusion}
framework four times, using the first results to discharge constraints in the
later ones. The last such result is the generic fusion result for substitution
with itself.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Fusion/Syntactic.tex]{subsub}
\caption{Generic Substitution-Substitution Fusion Principle}
\end{figure}

Another corollary of the fundamental lemma of fusion is the observation that
Kaiser, Schäfer, and Stark (\citeyear{Kaiser-wsdebr}) make: \emph{assuming
functional extensionality}, all of our kind-and-scope safe traversals are
compatible with variable renaming.
%
We reproduced this result generically for all syntaxes (see accompanying code).
The need for functional extensionality arises in the proof when dealing with
subterms which have extra bound variables. These terms are interpreted as
Kripke functional spaces in the host language and we can only prove that they
take equal inputs to equal outputs. An intensional notion of equality will
simply not do here.
%
As a consequence, we refrain from using the generic result in practice when
an axiom-free alternative is provable. Kaiser, Schäfer and Stark's observation
naturally raises the question of whether the same semantics are also stable
under substitution. Our semantics implementing printing with names is a clear
counter-example.
