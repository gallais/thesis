

\chapter{Building Generic Proofs about Generic Programs}

We have already shown in \cref{sec:simulationrel,sec:fusionrel} that, for the
simply typed $\lambda$-calculus, introducing an abstract notion of Semantics
not only reveals the shared structure of common traversals, it also allows
us to give abstract proof frameworks for simulation or fusion lemmas. These
ideas naturally extend to our generic presentation of semantics for all syntaxes.

\label{def:zipd}
The most important concept going forward is (\AF{Zip} \AB{d}), a relation
transformer which characterises structurally equal layers such that their
substructures are themselves related by the relation it is passed as an
argument. It inherits a lot of its relational arguments' properties: whenever
\AB{R} is reflexive (respectively symmetric or transitive) so is {\AF{Zip} \AB{d} \AB{R}}.\label{lem:zipstable}

It is defined by induction on the description and case analysis on the two
layers which are meant to be equal:
\begin{itemize}
  \item In the stop token case \AIC{`âˆ} \AB{i}, the two layers are considered to
    be trivially equal (i.e. the constraint generated is the unit type)
  \item When facing a recursive position {\AIC{`X} \AB{$\Delta$} \AB{j} \AB{d}}, we
    demand that the two substructures are related by {\AB{R} \AB{$\Delta$} \AB{j}}
    and that the rest of the layers are related by \AF{Zip} \AB{d} \AB{R}
  \item Two nodes of type {\AIC{`$\sigma$} \AB{A} \AB{d}} will
    be related if they both carry the same payload \AB{a} of type \AB{A} and if
    the rest of the layers are related by {\AF{Zip} (\AB{d} \AB{a}) \AB{R}}.
\end{itemize}

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Zip.tex]{ziptype}
\caption{Zip: Characterising Structurally Equal Values with Related Substructures}
\end{figure}

If we were to take a fixpoint of \AF{Zip}, we could obtain a structural
notion of equality for terms which we could prove equivalent to propositional
equality. Although interesting in its own right, we will instead focus on more
advanced use-cases.

\section{Simulation Lemma}\label{section:simulation}

We first revisit the \AR{Simulation} relation defined in \cref{sec:simulationrel}
for STLC, reusing as much as possible the same notations. A \AF{Zip} constraint
appears naturally when we want to say that a semantics can simulate another one.

Given a relation \AB{ğ“¥á´¿} connecting values in \AB{ğ“¥á´¬} and \AB{ğ“¥á´®}, and a relation
\AB{ğ“’á´¿} connecting computations in \AB{ğ“’á´¬} and \AB{ğ“’á´®}, we can define \AF{Kripkeá´¿}
relating values \AF{Kripke} \AB{ğ“¥á´¬} \AB{ğ“’á´¬} and \AF{Kripke} \AB{ğ“¥á´®} \AB{ğ“’á´®} by
stating that they send related inputs to related outputs. It is a generalisation of
the \AF{Kripkeá´¿} defined in \cref{fig:relationalkripke} to accomodate non-binders
and binders introducing more than one variable.

\begin{figure}[h]
\ExecuteMetaData[shared/Data/Var/Varlike.tex]{kripkeR}
\caption{Relational Kripke Function Spaces: From Related Inputs to Related Outputs}
\end{figure}

\subsection{Simulation Constraints}

We can then combine \AF{Zip} and \AF{Kripke\textsuperscript{R}} to formulate the
core of the \AR{Simulation} constraint. It is parametrised by a description, two
semantics and the two relations over values and computations respectively mentioned
earlier.

\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{recsim}

The set of constraint closely matches the ones spelt out in \cref{sec:simulationrel}.
We start with a constraint \ARF{thá´¿} stating that related values should still be
related once thinned.

\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{thR}

We then expect related values to yield related computations once \ARF{var}-wrapped.

\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{varR}

Finally, \ARF{algá´¿} express the idea that two semantic objects of respective types
\AF{âŸ¦} \AB{d} \AF{âŸ§} (\AF{Kripke} \AB{ğ“¥á´¬} \AB{ğ“’á´¬})
and \AF{âŸ¦} \AB{d} \AF{âŸ§} (\AF{Kripke} \AB{ğ“¥á´®} \AB{ğ“’á´®}) are in simulation by using
\AF{Zip} to force them to be in lock-step and \AF{Kripkeá´¿} to guarantee the subterms
are themselves in simulation.

\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{algR}

\subsection{Fundamental Lemma of Simulations}

The fundamental lemma of simulations is a generic theorem showing that for
each pair of \AR{Semantics} respecting the \AR{Simulation} constraints, we
get related computations given environments of related input values. This
theorem is once more mutually proven with a statement about \AF{Scope}s,
and \AD{Size}s play a crucial role in ensuring that the function is indeed total.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{simbody}
\caption{Fundamental Lemma of \AF{Simulation}s}
\end{figure}

\subsection{Applications}

Instantiating this generic simulation lemma, we can for instance get
that renaming and substitution are extensional (given extensionally
equal environments they produce syntactically equal terms), or that
renaming is a special case of substitution. Of course these results
are not new but having them generically over all syntaxes with binding
is convenient; which we have experienced first hand when tackling the
POPLMark Reloaded challenge where \AF{rensub} was actually needed

\todo{fix}
\begin{figure}[h]
% \ExecuteMetaData[Generic/Simulation.tex]{rensub}
\caption{Renaming as a Substitution via Simulation}
\end{figure}

When studying specific languages, new opportunities to deploy the
fundamental lemma of simulations arise. Our solution to the POPLMark
Reloaded challenge for instance describes the fact that ({\AF{sub} \AB{Ï} \AB{t}})
reduces to ({\AF{sub} \AB{Ï'} \AB{t}}) whenever for all \AB{v},
\AB{Ï}(\AB{v}) reduces to \AB{Ï'}(\AB{v}) as a \AR{Simulation}.
The main theorem (strong normalisation of STLC via a logical relation)
is itself an instance of (the unary version of) the simulation lemma,
that is to say the fundamental lemma of logical predicates.

The Simulation proof framework is the simplest examples of the abstract
proof frameworks we introduced in part 1 for the specific case of STLC.
We also explained how a similar framework can be defined
for fusion lemmas and deploy it for the renaming-substitution interactions
but also their respective interactions with normalisation by evaluation.
Now that we are familiarised with the techniques at hand, we can tackle
this more complex example for all syntaxes definable in our framework.

\section{Fusion Lemma}\label{section:fusion}

Results which can be reformulated as the ability to fuse two traversals
obtained as \AR{Semantics} into one abound. When claiming that \AF{Tm} is
a Functor, we have to prove that two successive renamings can be fused into
a single renaming where the \AF{Thinning}s have been composed. Similarly,
demonstrating that \AF{Tm} is a relative Monad~\cite{JFR4389} implies proving
that two consecutive substitutions can be merged into a single one whose
environment is the first one, where the second one has been applied in a
pointwise manner. The \emph{Substitution Lemma} central
to most model constructions (see for instance~\cite{mitchell1991kripke}) states
that a syntactic substitution followed by the evaluation of the resulting term
into the model is equivalent to the evaluation of the original term with an
environment corresponding to the evaluated substitution.

A direct application of these results is our (to be published) entry to the
POPLMark Reloaded challenge (\citeyear{poplmarkreloaded}). By using a \AD{Desc}-based
representation of intrinsically well typed and well scoped terms we directly inherit
not only renaming and substitution but also all four fusion lemmas as corollaries
of our generic results. This allows us to remove the usual boilerplate
and go straight to the point.
As all of these statements have precisely the same structure, we can
once more devise a framework which will, provided that its constraints are
satisfied, prove a generic fusion lemma.

Fusion is more involved than simulation so we will step through
each one of the constraints individually, trying to give the reader an intuition
for why they are shaped the way they are.


\subsection{The Fusion Constraints}

The notion of fusion is defined for a triple of \AR{Semantics}; each \AB{ğ“¢â±}
being defined for values in \AB{ğ“¥â±} and computations in \AB{ğ“’â±}. The
fundamental lemma associated to such a set of constraints will state that
running \AB{ğ“¢á´®} after \AB{ğ“¢á´¬} is equivalent to running \AB{ğ“¢á´¬á´®} only.

The definition of fusion is parametrised by three relations: \AB{ğ“”á´¿} relates
triples of environments of values in {(\AB{Î“} \AR{â”€Env}) \AB{ğ“¥á´¬} \AB{Î”}},
{(\AB{Î”} \AR{â”€Env}) \AB{ğ“¥á´®} \AB{Î˜}} and {(\AB{Î“} \AR{â”€Env}) \AB{ğ“¥á´¬á´®} \AB{Î˜}}
respectively; \AB{ğ“¥á´¿} relates pairs of values \AB{ğ“¥á´®} and \AB{ğ“¥á´¬á´®};
and \AB{ğ“’á´¿}, our notion of equivalence for evaluation results, relates pairs
of computation in \AB{ğ“’á´®} and \AB{ğ“’á´¬á´®}.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{fusionrec}

The first obstacle we face is the formal definition of ``running \AB{ğ“¢á´®}
after \AB{ğ“¢á´¬}'': for this statement to make sense, the result of running
\AB{ğ“¢á´¬} ought to be a term. Or rather, we ought to be able to extract a
term from a \AB{ğ“’á´¬}. Hence the first constraint: the existence of a
\ARF{reifyá´¬} function, which we supply as a field of the record \AR{Fusion}.
When dealing with syntactic semantics such as renaming or substitution
this function will be the identity. However nothing prevents to try to prove for
instance that normalisation by evaluation is idempotent in which case a bona fide
reification function extracting terms from model values will be used.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{quote}

Then, we have to think about what happens when going under a binder: \AB{ğ“¢á´¬}
will produce a \AF{Kripke} function space where a syntactic value is required.
Provided that \AB{ğ“¥á´¬} is \AR{VarLike}, we can make use of \AF{reify} to get a
\AF{Scope} back. Hence the second constraint.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{vlV}

We can combine these two functions to define the reification procedure we will
use in practice: \AF{quoteá´¬} which takes a Kripke function space and returns a
term by first feeding feeding placeholder values to the Kripke function space
and getting a \AB{ğ“’á´¬} and then reifying it thanks to \ARF{reifyá´¬}.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{quote}

Still thinking about going under binders: if three evaluation environments \AB{Ïá´¬} of
type {(\AB{Î“} \AR{â”€Env}) \AB{ğ“¥á´¬} \AB{Î”}}, \AB{ğ“¥á´®} in {(\AB{Î”} \AR{â”€Env}) \AB{ğ“¥á´®} \AB{Î˜}},
and \AB{Ïá´¬á´®} in {(\AB{Î“} \AR{â”€Env}) \AB{ğ“¥á´¬á´®} \AB{Î˜}} are related by \AB{ğ“”á´¿} and we are
given a thinning \AB{Ï} from \AB{Î˜} to \AB{Î©} then \AB{Ïá´¬}, the thinned \AB{ğ“¥á´®} and the
thinned \AB{Ïá´¬á´®} should still be related.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{thV}

Remembering that \AF{\_>>\_} is used in the definition of \AF{body} (cf. \cref{fig:genbody})
to combine two disjoint environments {(\AB{Î“} \AR{â”€Env}) \AB{ğ“¥} \AB{Î˜}} and
{(\AB{Î”} \AR{â”€Env}) \AB{ğ“¥} \AB{Î˜}} into one of type
{((\AB{Î“} \AF{++} \AB{Î”}) \AR{â”€Env}) \AB{ğ“¥} \AB{Î˜})}, we mechanically need a
constraint stating that \AF{\_>>\_} is compatible with \AB{ğ“”á´¿}. We demand
as an extra precondition that the values \AB{Ïá´®} and \AB{Ïá´¬á´®} are extended
with are related in a pointwise manner according to \AB{ğ“¥á´¿}. Lastly, for all
the types to match up, \AB{Ïá´¬} has to be extended with placeholder variables
which we can do thanks to the \AR{VarLike} constraint \ARF{vl\textasciicircum{}ğ“¥á´¬}.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{appendR}

We finally arrive at the constraints focusing on the semantical counterparts
of the terms' constructors. In order to have readable type we introduce an
auxiliary definition \AF{ğ“¡}. Just like in \cref{sec:fusionrel}, it relates at
a given type a term and three environments by stating that sequentially evaluating
the term in the first and then the second environment on the one hand and directly
evaluating the term in the third environment on the other yields related computations.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{crel}

As one would expect, the \ARF{vará´¿} constraint states that from related environments
the two evaluation processes described by \AF{ğ“¡} yield related outputs.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{varR}

The case of the algebra follows a similar idea albeit being more complex. It states
that we should be able to prove that a \AIC{`con}-headed term's evaluations are related
according to \AF{ğ“¡} provided that the evaluation of the constructor's body one way or
the other yields structurally similar results (hence the use of the ({\AF{Zip} \AB{d}})
relation transformer defined in \cref{def:zipd}) where the relational Kripke function
space relates the semantical objects one can find in place of the subterms.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{algR}

\subsection{Fundamental Lemma of Fusion}

This set of constraint is enough to prove a fundamental lemma of \AR{Fusion} stating
that from a triple of related environments, one gets a pair of related computations:
the composition of \AB{ğ“¢á´¬} and \AB{ğ“¢á´®} on one hand and \AB{ğ“¢á´¬á´®} on the other. This
lemma is once again proven mutually with its counterpart for \AR{Semantics}' \AF{body}'s
action on \AR{Scope}s.

\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{fusiontype}
\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{bodytype}
\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{fusioncode}
\ExecuteMetaData[generic-syntax.agda/Generic/Fusion.tex]{bodycode}

\todo{proof}

\subsection{Applications}

A direct consequence of this result is the four lemmas collectively stating
that any pair of renamings and / or substitutions can be fused together to
produce either a renaming (in the renaming-renaming interaction case) or a
substitution (in all the other cases). One such example is the fusion of
substitution followed by renaming into a single substitution where the
renaming has been applied to the environment.

\todo{example}

Another corollary of the fundamental lemma of fusion is the observation that
Kaiser, SchÃ¤fer, and Stark (\citeyear{Kaiser-wsdebr}) make: \emph{assuming
  functional extensionality}, all of our kind-and-scope safe traversals are
compatible with variable renaming. We can reproduce this result generically
for all syntaxes (see accompanying code) but refrain from using it in practice
when an axiom-free alternative is provable.
