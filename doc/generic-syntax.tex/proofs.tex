

\chapter{Building Generic Proofs about Generic Programs}

We have already shown that, for the simply typed $\lambda$-calculus, introducing an
abstract notion of Semantics not only reveals the shared structure of common
traversals, it also allows us to give abstract proof frameworks for
simulation or fusion lemmas. These ideas naturally extend to our generic
presentation of semantics for all syntaxes.

The most important concept going forward is (\AF{Zip} \AB{d}), a relation
transformer which characterises structurally equal layers such that their
substructures are themselves related by the relation it is passed as an
argument. It inherits a lot of its relational arguments' properties: whenever
\AB{R} is reflexive (respectively symmetric or transitive) so is {\AF{Zip} \AB{d} \AB{R}}.\label{lem:zipstable}

It is defined by induction on the description and case analysis on the two
layers which are meant to be equal:
\begin{itemize}
  \item In the stop token case \AIC{`âˆ} \AB{i}, the two layers are considered to
    be trivially equal (i.e. the constraint generated is the unit type)
  \item When facing a recursive position {\AIC{`X} \AB{$\Delta$} \AB{j} \AB{d}}, we
    demand that the two substructures are related by {\AB{R} \AB{$\Delta$} \AB{j}}
    and that the rest of the layers are related by \AF{Zip} \AB{d} \AB{R}
  \item Two nodes of type {\AIC{`$\sigma$} \AB{A} \AB{d}} will
    be related if they both carry the same payload \AB{a} of type \AB{A} and if
    the rest of the layers are related by {\AF{Zip} (\AB{d} \AB{a}) \AB{R}}.
\end{itemize}

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Zip.tex]{ziptype}
\caption{Zip: Characterising Structurally Equal Values with Related Substructures}
\end{figure}

If we were to take a fixpoint of \AF{Zip}, we could obtain a structural
notion of equality for terms which we could prove equivalent to propositional
equality. Although interesting in its own right, we will instead focus on more
advanced use-cases.

\section{Simulation Lemma}\label{section:simulation}

We first revisit the \AR{Simulation} relation defined in \cref{sec:simulationrel}
for STLC, reusing as much as possible the same notations. A \AF{Zip} constraint
appears naturally when we want to say that a semantics can simulate another one.

Given a relation \AB{ğ“¥á´¿} connecting values in \AB{ğ“¥á´¬} and \AB{ğ“¥á´®}, and a relation
\AB{ğ“’á´¿} connecting computations in \AB{ğ“’á´¬} and \AB{ğ“’á´®}, we can define \AF{Kripkeá´¿}
relating values \AF{Kripke} \AB{ğ“¥á´¬} \AB{ğ“’á´¬} and \AF{Kripke} \AB{ğ“¥á´®} \AB{ğ“’á´®} by
stating that they send related inputs to related outputs. It is a generalisation of
the \AF{Kripkeá´¿} defined in \cref{fig:relationalkripke} to accomodate non-binders
and binders introducing more than one variable.

\begin{figure}[h]
\ExecuteMetaData[shared/Data/Var/Varlike.tex]{kripkeR}
\caption{Relational Kripke Function Spaces: From Related Inputs to Related Outputs}
\end{figure}

\subsection{Simulation Constraints}

We can then combine \AF{Zip} and \AF{Kripke\textsuperscript{R}} to formulate the
core of the \AR{Simulation} constraint. It is parametrised by a description, two
semantics and the two relations over values and computations respectively mentioned
earlier.

\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{recsim}

The set of constraint closely matches the ones spelt out in \cref{sec:simulationrel}.
We start with a constraint \ARF{thá´¿} stating that related values should still be
related once thinned.

\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{thR}

We then expect related values to yield related computations once \ARF{var}-wrapped.

\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{varR}

Finally, \ARF{algá´¿} express the idea that two semantic objects of respective types
\AF{âŸ¦} \AB{d} \AF{âŸ§} (\AF{Kripke} \AB{ğ“¥á´¬} \AB{ğ“’á´¬})
and \AF{âŸ¦} \AB{d} \AF{âŸ§} (\AF{Kripke} \AB{ğ“¥á´®} \AB{ğ“’á´®}) are in simulation by using
\AF{Zip} to force them to be in lock-step and \AF{Kripkeá´¿} to guarantee the subterms
are themselves in simulation.

\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{algR}

\subsection{Fundamental Lemma of Simulations}

The fundamental lemma of simulations is a generic theorem showing that for
each pair of \AR{Semantics} respecting the \AR{Simulation} constraints, we
get related computations given environments of related input values. This
theorem is once more mutually proven with a statement about \AF{Scope}s,
and \AD{Size}s play a crucial role in ensuring that the function is indeed total.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{simbody}
\caption{Fundamental Lemma of \AF{Simulation}s}
\end{figure}

\subsection{Applications}

Instantiating this generic simulation lemma, we can for instance get
that renaming and substitution are extensional (given extensionally
equal environments they produce syntactically equal terms), or that
renaming is a special case of substitution. Of course these results
are not new but having them generically over all syntaxes with binding
is convenient; which we have experienced first hand when tackling the
POPLMark Reloaded challenge where \AF{rensub} was actually needed

\todo{fix}
\begin{figure}[h]
% \ExecuteMetaData[Generic/Simulation.tex]{rensub}
\caption{Renaming as a Substitution via Simulation}
\end{figure}

When studying specific languages, new opportunities to deploy the
fundamental lemma of simulations arise. Our solution to the POPLMark
Reloaded challenge for instance describes the fact that ({\AF{sub} \AB{Ï} \AB{t}})
reduces to ({\AF{sub} \AB{Ï'} \AB{t}}) whenever for all \AB{v},
\AB{Ï}(\AB{v}) reduces to \AB{Ï'}(\AB{v}) as a \AR{Simulation}.
The main theorem (strong normalisation of STLC via a logical relation)
is itself an instance of (the unary version of) the simulation lemma,
that is to say the fundamental lemma of logical predicates.

The Simulation proof framework is the simplest examples of the abstract
proof frameworks we introduced in part 1 for the specific case of STLC.
We also explained how a similar framework can be defined
for fusion lemmas and deploy it for the renaming-substitution interactions
but also their respective interactions with normalisation by evaluation.
Now that we are familiarised with the techniques at hand, we can tackle
this more complex example for all syntaxes definable in our framework.

\section{Fusion Lemma}\label{section:fusion}

Results which can be reformulated as the ability to fuse two traversals
obtained as \AR{Sem}antics into one abound. When claiming that \AF{Tm} is
a Functor, we have to prove that two successive renamings can be fused into
a single renaming where the \AF{Thinning}s have been composed. Similarly,
demonstrating that \AF{Tm} is a relative Monad~\cite{JFR4389} implies proving
that two consecutive substitutions can be merged into a single one whose
environment is the first one, where the second one has been applied in a
pointwise manner. The \emph{Substitution Lemma} central
to most model constructions (see for instance~\cite{mitchell1991kripke}) states
that a syntactic substitution followed by the evaluation of the resulting term
into the model is equivalent to the evaluation of the original term with an
environment corresponding to the evaluated substitution.

A direct application of these results is our (to be published) entry to the
POPLMark Reloaded challenge (\citeyear{poplmarkreloaded}). By using a \AD{Desc}-based
representation of intrinsically well typed and well scoped terms we directly inherit
not only renaming and substitution but also all four fusion lemmas as corollaries
of our generic results. This allows us to remove the usual boilerplate
and go straight to the point.
As all of these statements have precisely the same structure, we can
once more devise a framework which will, provided that its constraints are
satisfied, prove a generic fusion lemma.

Fusion is more involved than simulation so we will step through
each one of the constraints individually, trying to give the reader an intuition
for why they are shaped the way they are.


\subsection{The Fusion Constraints}

The notion of fusion is defined for a triple of \AR{Semantics}; each \AB{ğ“¢â±}
being defined for values in \AB{ğ“¥â±} and computations in \AB{ğ“’â±}. The
fundamental lemma associated to such a set of constraints will state that
running \AB{ğ“¢á´®} after \AB{ğ“¢á´¬} is equivalent to running \AB{ğ“¢á´¬á´®} only.

The definition of fusion is parametrised by three relations: \AB{ğ“”á´¿} relates
triples of environments of values in {(\AB{Î“} \AR{â”€Env}) \AB{ğ“¥á´¬} \AB{Î”}},
{(\AB{Î”} \AR{â”€Env}) \AB{ğ“¥á´®} \AB{Î˜}} and {(\AB{Î“} \AR{â”€Env}) \AB{ğ“¥á´¬á´®} \AB{Î˜}}
respectively; \AB{ğ“¥á´¿} relates pairs of values \AB{ğ“¥á´®} and \AB{ğ“¥á´¬á´®};
and \AB{ğ“’á´¿}, our notion of equivalence for evaluation results, relates pairs
of computation in \AB{ğ“’á´®} and \AB{ğ“’á´¬á´®}.
