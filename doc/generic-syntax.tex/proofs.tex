

\chapter{Building Generic Proofs about Generic Programs}

We have already shown that, for the simply typed $\lambda$-calculus, introducing an
abstract notion of Semantics not only reveals the shared structure of common
traversals, it also allows us to give abstract proof frameworks for
simulation or fusion lemmas. These ideas naturally extend to our generic
presentation of semantics for all syntaxes.

The most important concept going forward is (\AF{Zip} \AB{d}), a relation
transformer which characterises structurally equal layers such that their
substructures are themselves related by the relation it is passed as an
argument. It inherits a lot of its relational arguments' properties: whenever
\AB{R} is reflexive (respectively symmetric or transitive) so is {\AF{Zip} \AB{d} \AB{R}}.\label{lem:zipstable}

It is defined by induction on the description and case analysis on the two
layers which are meant to be equal:
\begin{itemize}
  \item In the stop token case \AIC{`‚àé} \AB{i}, the two layers are considered to
    be trivially equal (i.e. the constraint generated is the unit type)
  \item When facing a recursive position {\AIC{`X} \AB{$\Delta$} \AB{j} \AB{d}}, we
    demand that the two substructures are related by {\AB{R} \AB{$\Delta$} \AB{j}}
    and that the rest of the layers are related by \AF{Zip} \AB{d} \AB{R}
  \item Two nodes of type {\AIC{`$\sigma$} \AB{A} \AB{d}} will
    be related if they both carry the same payload \AB{a} of type \AB{A} and if
    the rest of the layers are related by {\AF{Zip} (\AB{d} \AB{a}) \AB{R}}.
\end{itemize}

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Zip.tex]{ziptype}
\caption{Zip: Characterising Structurally Equal Values with Related Substructures}
\end{figure}

If we were to take a fixpoint of \AF{Zip}, we could obtain a structural
notion of equality for terms which we could prove equivalent to propositional
equality. Although interesting in its own right, we will instead focus on more
advanced use-cases.

\section{Simulation Lemma}\label{section:simulation}

We first revisit the \AR{Simulation} relation defined in \cref{sec:simulationrel}
for STLC, reusing as much as possible the same notations. A \AF{Zip} constraint
appears naturally when we want to say that a semantics can simulate another one.

Given a relation \AB{ùì•·¥ø} connecting values in \AB{ùì•·¥¨} and \AB{ùì•·¥Æ}, and a relation
\AB{ùìí·¥ø} connecting computations in \AB{ùìí·¥¨} and \AB{ùìí·¥Æ}, we can define \AF{Kripke·¥ø}
relating values \AF{Kripke} \AB{ùì•·¥¨} \AB{ùìí·¥¨} and \AF{Kripke} \AB{ùì•·¥Æ} \AB{ùìí·¥Æ} by
stating that they send related inputs to related outputs. It is a generalisation of
the \AF{Kripke·¥ø} defined in \cref{fig:relationalkripke} to accomodate non-binders
and binders introducing more than one variable.

\begin{figure}[h]
\ExecuteMetaData[shared/Data/Var/Varlike.tex]{kripkeR}
\caption{Relational Kripke Function Spaces: From Related Inputs to Related Outputs}
\end{figure}

\subsection{Simulation Constraints}

We can then combine \AF{Zip} and \AF{Kripke\textsuperscript{R}} to formulate the
core of the \AR{Simulation} constraint. It is parametrised by a description, two
semantics and the two relations over values and computations respectively mentioned
earlier.

\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{recsim}

The set of constraint closely matches the ones spelt out in \cref{sec:simulationrel}.
We start with a constraint \ARF{th·¥ø} stating that related values should still be
related once thinned.

\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{thR}

We then expect related values to yield related computations once \ARF{var}-wrapped.

\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{varR}

Finally, \ARF{alg·¥ø} express the idea that two semantic objects of respective types
\AF{‚ü¶} \AB{d} \AF{‚üß} (\AF{Kripke} \AB{ùì•·¥¨} \AB{ùìí·¥¨})
and \AF{‚ü¶} \AB{d} \AF{‚üß} (\AF{Kripke} \AB{ùì•·¥Æ} \AB{ùìí·¥Æ}) are in simulation by using
\AF{Zip} to force them to be in lock-step and \AF{Kripke·¥ø} to guarantee the subterms
are themselves in simulation.

\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{algR}

\subsection{Fundamental Lemma of Simulations}

The fundamental lemma of simulations is a generic theorem showing that for
each pair of \AR{Semantics} respecting the \AR{Simulation} constraints, we
get related computations given environments of related input values. This
theorem is once more mutually proven with a statement about \AF{Scope}s,
and \AD{Size}s play a crucial role in ensuring that the function is indeed total.

\begin{figure}[h]
\ExecuteMetaData[generic-syntax.agda/Generic/Simulation.tex]{simbody}
\caption{Fundamental Lemma of \AF{Simulation}s}
\end{figure}

\subsection{Applications}

Instantiating this generic simulation lemma, we can for instance get
that renaming and substitution are extensional (given extensionally
equal environments they produce syntactically equal terms), or that
renaming is a special case of substitution. Of course these results
are not new but having them generically over all syntaxes with binding
is convenient; which we have experienced first hand when tackling the
POPLMark Reloaded challenge where \AF{rensub} was actually needed

\todo{fix}
\begin{figure}[h]
% \ExecuteMetaData[Generic/Simulation.tex]{rensub}
\caption{Renaming as a Substitution via Simulation}
\end{figure}

When studying specific languages, new opportunities to deploy the
fundamental lemma of simulations arise. Our solution to the POPLMark
Reloaded challenge for instance describes the fact that ({\AF{sub} \AB{œÅ} \AB{t}})
reduces to ({\AF{sub} \AB{œÅ'} \AB{t}}) whenever for all \AB{v},
\AB{œÅ}(\AB{v}) reduces to \AB{œÅ'}(\AB{v}) as a \AR{Simulation}.
The main theorem (strong normalisation of STLC via a logical relation)
is itself an instance of (the unary version of) the simulation lemma,
that is to say the fundamental lemma of logical predicates.

The Simulation proof framework is the simplest examples of the abstract
proof frameworks we introduced in part 1 for the specific case of STLC.
We also explained how a similar framework can be defined
for fusion lemmas and deploy it for the renaming-substitution interactions
but also their respective interactions with normalisation by evaluation.
Now that we are familiarised with the techniques at hand, we can tackle
this more complex example for all syntaxes definable in our framework.

