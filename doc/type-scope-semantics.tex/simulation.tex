\chapter{The Simulation Relation}

Thanks to \AF{Semantics}, we have already saved work by not reiterating the
same traversals. Moreover, this disciplined approach to building models and
defining the associated evaluation functions can help us refactor the proofs
of some properties of these semantics.

Instead of using proof scripts as Benton et al.~(\citeyear{benton2012strongly})
do, we describe abstractly the constraints the logical relations~\cite{reynolds1983types}
defined on computations (and environment values) have to respect to ensure
that evaluating a term in related environments
produces related outputs. This gives us a generic framework to
state and prove, in one go, properties about all of these semantics.

Our first example of such a framework will stay simple on purpose.
However it is no mere bureaucracy: the
result proven here will actually be useful in the next section
when considering more complex properties.

This first example is describing the relational interpretation of the terms.
It should give the reader a good introduction to the setup before we take on
more complexity. The types involved might look a bit scarily abstract but the
idea is rather simple: we have a \AR{Simulation} between two \AR{Semantics}
when evaluating a term in related environments yields related values. The bulk
of the work is to make this intuition formal.

\section{Relations Between Scoped Families}

We start by defining what it means to be a relation between two \scoped{\AB{I}}
families \AB{T} and \AB{U}: at every type \AB{œÉ} and every context \AB{Œì}, we
expect to have a relation between (\AB{T}~\AB{œÉ}~\AB{Œì}) and (\AB{U}~\AB{œÉ}~\AB{Œì}).
We use a \AK{record} wrapper for two reasons. First, we define the relations we
are interested in by copattern-matching thus preventing their eager unfolding by
Agda; this makes the goals much more readable during interactive development.
Second, it is easier for Agda to recover \AB{T} and \AB{U} by unification when
they appear as explicit parameters of a record rather than as applied families
in the body of the definition.

\begin{figure}[h]
\ExecuteMetaData[shared/Data/Relation.tex]{rel}
\caption{Relation Between \scoped{\AB{I}} Families}
\end{figure}

If we have a relation for values, we can lift it in a pointwise manner to a relation
on environment of values. We call this relation transformer \AR{All}. We also define
it using a \AK{record} wrapper, for the same reasons.

\begin{figure}[h]
\ExecuteMetaData[shared/Data/Relation.tex]{all}
\caption{Relation Between Environments of Values}
\end{figure}

For virtually every combinator on environments, we have a corresponding combinator
for \AR{All}: the empty environment \AF{Œµ} is associated to \AF{Œµ·¥ø} the proof that
two empty environments are always related, to the environment extension  \AF{\_‚àô\_}
corresponds the relation on environment extension \AF{\_‚àô·¥ø\_} which provided takes a
proof that two environments are related and that two values are related and returns
the proof that the environments each extended with the appropriate value are both
related.

Once we have all of these definitions, we can spell out what it means to simulate
a semantics with another.

\section{Simulation Constraints}

The evidence that we have a \AR{Simulation} between two \AR{Semantics} is
packaged in a record indexed by the semantics as well as two relations.
The first one (\AB{ùì•·¥ø}) relates values in the respective environments
and the second one (\AB{ùìí·¥ø}) describes simulation for computations.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{simulation}

The set of simulation constraints is in one-to-one correspondance with that of
semantical constructs. We start with value thinnings: provided two values are
related, their respective thinnings should still be related.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{thV}

Our other constraints are going to heavily feature \AB{ùìí·¥ø} applied to one term evaluated
twice: once by \AB{ùì¢·¥¨} with the environment of values \AB{œÅ·¥¨} and once by \AB{ùì¢·¥Æ} with
\AB{œÅ·¥Æ}. To make the types more readable, we introduce an intermediate definition \AB{ùì°}
making this pattern explicit.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{crel}

The relational counterpart of \AIC{`var} and \ARF{var} is the first field to make use
of \AB{ùì°}: provided that \AB{œÅ·¥¨} and \AB{œÅ·¥Æ} carry values related by \AB{ùì•·¥ø}, the result
of evaluating the variable \AB{v} in each respectively should yield computations related
by \AB{ùìí·¥ø}.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{var}

Value constructors in the language follow a similar pattern: provided that the evaluation
environment are related, we expect the computations to be related too.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{base}

Then come the structural cases: for language constructs like \AIC{`app} and \AIC{`ifte}
whose subterms live in the same context as the overall term, the constraints are purely
structural. Provided that the evaluation environments are related, and that the evaluation
of the subterms in each environment respectively are related then the evaluations of the
overall terms should also yield related results.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{struct}

Finally, we reach the most interesting case. The semantics attached to the body of a
\AIC{`lam} is expressed in terms of a Kripke function space. As a consequence, the
relational semantics will need a relational notion of Kripke function space (\AF{Kripke·¥ø})
to spell out the appropriate simulation constraint. This relational Kripke function space
states that in any thinning of the evaluation context and provided two related inputs,
the evaluation of the body in each thinned environment extended with the appropriate
value should yield related computations.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{rkripke}

This allows us to describe the constraint for \AIC{`lam}: provided related environments
of values, if we have a relational Kripke function space for the body of the \AIC{`lam}
then both evaluations should yield related results.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{lam}

This specification is only useful if it is accompanied by a a fundamental lemma of
simulations stating that the evaluation of a term on related inputs yields related
outputs.

\section{Fundamental Lemma of Simulations}

Given two Semantics \AB{ùì¢·¥¨} and \AB{ùì¢·¥Æ} in simulation with respect to relations
\AB{ùì•·¥ø} for values and \AB{ùìí·¥ø} for computations, we have that for any term \AB{t}
and environments \AB{œÅ·¥¨} and \AB{œÅ·¥Æ}, if the two environments are \AB{ùì•·¥ø}-related
in a pointwise manner then the semantics associated to \AB{t} by \AB{ùì¢·¥¨} using \AB{œÅ·¥¨}
is \AB{ùìí·¥ø}-related to the one associated to \AB{t} by \AB{ùì¢} using \AB{œÅ·¥Æ}.

In a manner reminiscent of our proof of the fundamental lemma of \AR{Semantics}, we
introduce a \AM{Fundamental} module parametrised by a record packing the evidence
that two semantics are in \AR{Simulation}. This allows us to bring all of the
corresponding relational counterpart of term constructors into scope by \AK{open}ing
the record. The traversal then uses them to combine the induction hypotheses arising
structurally.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{fundamental}



\section{Syntactic Traversals are Extensional}

A first corollary of the fundamental lemma of simulations is the fact that semantics
arising from a \AR{Syntactic} (cf.~\cref{syntactic}) definition are extensional. That
is to say that the evaluation function yields propositionally equal values provided
extensionally equal environments of values.

Under the assumption that \AB{Syn} is a \AR{Syntactic} instance, we can define the
corresponding \AR{Semantics} \AB{ùì¢} by setting
\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{synsem}.
Using \AF{Eq·¥ø} the \AR{Rel} defined as the pontwise lifting of propositional equality,
we can make our earlier claim formal and prove it. All the constraints are discharged
either by reflexivity or by using congruence to combine various hypotheses.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{syn-ext}

Because the \AR{Simulation} statement is not necessarily extremely illuminating, we spell
out the type of the corollary to clarify what we just proved: whenever two environments
agree on each variable, evaluating a term with either of them produces equal results.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{synext}

\section{The PER for Œ≤ŒπŒæŒ∑-Values is Closed under Evaluation}
