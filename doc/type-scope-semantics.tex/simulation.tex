\chapter{The Simulation Relation}
\label{sec:simulationrel}

Thanks to \AF{Semantics}, we have already saved work by not reiterating the
same traversals. Moreover, this disciplined approach to building models and
defining the associated evaluation functions can help us refactor the proofs
of some properties of these semantics.

Instead of using proof scripts as Benton et al.~(\citeyear{benton2012strongly})
do, we describe abstractly the constraints the logical relations~\cite{reynolds1983types}
defined on computations (and environment values) have to respect to ensure
that evaluating a term in related environments
produces related outputs. This gives us a generic framework to
state and prove, in one go, properties about all of these semantics.

Our first example of such a framework will stay simple on purpose.
However it is no mere bureaucracy: the
result proven here will actually be useful in the next section
when considering more complex properties.

This first example is describing the relational interpretation of the terms.
It should give the reader a good introduction to the setup before we take on
more complexity. The types involved might look a bit scarily abstract but the
idea is rather simple: we have a \AR{Simulation} between two \AR{Semantics}
when evaluating a term in related environments yields related values. The bulk
of the work is to make this intuition formal.

\section{Relations Between Scoped Families}

We start by defining what it means to be a relation between two \scoped{\AB{I}}
families \AB{T} and \AB{U}: at every type \AB{œÉ} and every context \AB{Œì}, we
expect to have a relation between (\AB{T}~\AB{œÉ}~\AB{Œì}) and (\AB{U}~\AB{œÉ}~\AB{Œì}).
We use a \AK{record} wrapper for two reasons. First, we define the relations we
are interested in by copattern-matching thus preventing their eager unfolding by
Agda; this makes the goals much more readable during interactive development.
Second, it is easier for Agda to recover \AB{T} and \AB{U} by unification when
they appear as explicit parameters of a record rather than as applied families
in the body of the definition.

\begin{figure}[h]
\ExecuteMetaData[shared/Data/Relation.tex]{rel}
\caption{Relation Between \scoped{\AB{I}} Families}
\end{figure}

If we have a relation for values, we can lift it in a pointwise manner to a relation
on environment of values. We call this relation transformer \AR{All}. We also define
it using a \AK{record} wrapper, for the same reasons.

\begin{figure}[h]
\ExecuteMetaData[shared/Data/Relation.tex]{all}
\caption{Relation Between Environments of Values}
\end{figure}

For virtually every combinator on environments, we have a corresponding combinator
for \AR{All}: the empty environment \AF{Œµ} is associated to \AF{Œµ·¥ø} the proof that
two empty environments are always related, to the environment extension  \AF{\_‚àô\_}
corresponds the relation on environment extension \AF{\_‚àô·¥ø\_} which provided takes a
proof that two environments are related and that two values are related and returns
the proof that the environments each extended with the appropriate value are both
related.

Once we have all of these definitions, we can spell out what it means to simulate
a semantics with another.

\section{Simulation Constraints}

The evidence that we have a \AR{Simulation} between two \AR{Semantics} is
packaged in a record indexed by the semantics as well as two relations.
The first one (\AB{ùì•·¥ø}) relates values in the respective environments
and the second one (\AB{ùìí·¥ø}) describes simulation for computations.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{simulation}

The set of simulation constraints is in one-to-one correspondance with that of
semantical constructs. We start with value thinnings: provided two values are
related, their respective thinnings should still be related.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{thV}

Our other constraints are going to heavily feature \AB{ùìí·¥ø} applied to one term evaluated
twice: once by \AB{ùì¢·¥¨} with the environment of values \AB{œÅ·¥¨} and once by \AB{ùì¢·¥Æ} with
\AB{œÅ·¥Æ}. To make the types more readable, we introduce an intermediate definition \AB{ùì°}
making this pattern explicit.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{crel}

The relational counterpart of \AIC{`var} and \ARF{var} is the first field to make use
of \AB{ùì°}: provided that \AB{œÅ·¥¨} and \AB{œÅ·¥Æ} carry values related by \AB{ùì•·¥ø}, the result
of evaluating the variable \AB{v} in each respectively should yield computations related
by \AB{ùìí·¥ø}.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{var}

Value constructors in the language follow a similar pattern: provided that the evaluation
environment are related, we expect the computations to be related too.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{base}

Then come the structural cases: for language constructs like \AIC{`app} and \AIC{`ifte}
whose subterms live in the same context as the overall term, the constraints are purely
structural. Provided that the evaluation environments are related, and that the evaluation
of the subterms in each environment respectively are related then the evaluations of the
overall terms should also yield related results.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{struct}

Finally, we reach the most interesting case. The semantics attached to the body of a
\AIC{`lam} is expressed in terms of a Kripke function space. As a consequence, the
relational semantics will need a relational notion of Kripke function space (\AF{Kripke·¥ø})
to spell out the appropriate simulation constraint. This relational Kripke function space
states that in any thinning of the evaluation context and provided two related inputs,
the evaluation of the body in each thinned environment extended with the appropriate
value should yield related computations.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{rkripke}
\caption{Relational Kripke Function Spaces: From Related Inputs to Related Outputs\label{fig:relationalkripke}}
\end{figure}

This allows us to describe the constraint for \AIC{`lam}: provided related environments
of values, if we have a relational Kripke function space for the body of the \AIC{`lam}
then both evaluations should yield related results.

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{lam}

This specification is only useful if it is accompanied by a a fundamental lemma of
simulations stating that the evaluation of a term on related inputs yields related
outputs.

\section{Fundamental Lemma of Simulations}

Given two Semantics \AB{ùì¢·¥¨} and \AB{ùì¢·¥Æ} in simulation with respect to relations
\AB{ùì•·¥ø} for values and \AB{ùìí·¥ø} for computations, we have that for any term \AB{t}
and environments \AB{œÅ·¥¨} and \AB{œÅ·¥Æ}, if the two environments are \AB{ùì•·¥ø}-related
in a pointwise manner then the semantics associated to \AB{t} by \AB{ùì¢·¥¨} using \AB{œÅ·¥¨}
is \AB{ùìí·¥ø}-related to the one associated to \AB{t} by \AB{ùì¢} using \AB{œÅ·¥Æ}.

In a manner reminiscent of our proof of the fundamental lemma of \AR{Semantics}, we
introduce a \AM{Fundamental} module parametrised by a record packing the evidence
that two semantics are in \AR{Simulation}. This allows us to bring all of the
corresponding relational counterpart of term constructors into scope by \AK{open}ing
the record. The traversal then uses them to combine the induction hypotheses arising
structurally.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Specification.tex]{fundamental}
\caption{Fundamental Lemma of \AR{Simulation}s\label{fig:fundsim}}
\end{figure}

We can now consider the second criterion for usefulness: the existence of interesting
instances of a \AR{Simulation}.

\section{Syntactic Traversals are Extensional}

A first corollary of the fundamental lemma of simulations is the fact that semantics
arising from a \AR{Syntactic} (cf.~\cref{fig:syntactic}) definition are extensional. We
can demonstrate this by proving that every syntactic semantics is in simulation with
itself. That is to say that the evaluation function yields propositionally equal
values provided extensionally equal environments of values.

Under the assumption that \AB{Syn} is a \AR{Syntactic} instance, we can define the
corresponding \AR{Semantics} \AB{ùì¢} by setting
\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{synsem}.
Using \AF{Eq·¥ø} the \AR{Rel} defined as the pontwise lifting of propositional equality,
we can make our earlier claim formal and prove it. All the constraints are discharged
either by reflexivity or by using congruence to combine various hypotheses.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{syn-ext}
\caption{\AR{Syntactic}~ Traversals are in \AR{Simulation}~ with Themselves\label{fig:synselfsim}}
\end{figure}

Because the \AR{Simulation} statement is not necessarily extremely illuminating, we spell
out the type of the corollary to clarify what we just proved: whenever two environments
agree on each variable, evaluating a term with either of them produces equal results.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{synext}
\caption{\AR{Syntactic}~ Traversals are Extensional\label{fig:synextensional}}
\end{figure}

This may look like a trivial result however we have found multiple use cases for it
during the development of our solution to the POPLMark Reloaded challenge (\citeyear{poplmark2}):
when reasoning by equational reasoning, it is often the case that we can make progress
on each side of the equation only to meet in the middle with the same traversals using
two slightly different environments. This lemma allows us to bridge that last gap.

\section{Renaming is a Substitution}

Similarly, it is sometimes the case that after a bit of rewriting we end up with an
equality between one renaming and one substitution. But it turns out that as long as
the substitution is only made up variables, it is indeed equal to the corresponding
renaming. We can make this idea formal by introducting the \AF{VarTerm·¥ø} relation
stating that a variable and a term are morally equal like so:

\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{varterm}

We can then state our result: we can prove a simulation lemma between \AF{Renaming}
and \AF{Substitution} where values (i.e. variables in the cases of renaming and terms
in terms of substitution) are related by \AF{VarTerm·¥ø} and computations (i.e. terms)
are related by \AF{Eq·¥ø}. Once again we proceed by reflexivity and congruence.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{renissub}
\caption{\AF{Renaming}~ is in \AR{Simulation}~ with \AF{Substitution}\label{fig:renissub}}
\end{figure}

Rather than showing one more time the type of the corollary, we show a specialized
version where we pick the substitution to be precisely the thinning used on which we
have mapped the \AIC{`var} constructor.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{renassub}
\caption{Renaming as a Substitution\label{fig:renassub}}
\end{figure}

\section{The PER for Œ≤ŒπŒæŒ∑-Values is Closed under Evaluation}

Now that we are a bit more used to the simulation framework and simulation lemmas,
we can look at a more complex example: the simulation lemma relating normalisation
by evaluation's \AF{eval} function to itself. This may seem bureaucratic but it is
crucial: the model definition uses the host language's function space which contains
more functions than just the ones obtained by evaluating a simply-typed $Œª$-term.
A value at type {(\AIC{`Bool} \AIC{`‚Üí} \AIC{`Bool})} may for instance behave like
boolean negation on canonical terms but be the constant \AIC{`tt} function on neutral
value. It does not correspond to any term in the source language: any candidate term
would allow us to write expressions not stable under substitution!

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIotaXiEta.tex]{exotic}
\caption{Exotic Value, Not Quite Equal to Negation\label{fig:nbeexotic}}
\end{figure}

Clearly, these exotic functions have undesirable behaviours and need to be ruled out
if we want to be able to prove that normalisation has good properties. This is done
by defining a Partial Equivalence Relation (PER) (\cite{mitchell1996foundations})
on the model which is to say a relation which is symmetric and transitive but may
not be reflexive for all elements in its domain. The elements equal to themselves will be
guaranteed to be well behaved. We show that given an environment of values PER-related to
themselves, the evaluation of a $Œª$-term produces a computation equal to itself too.


We start by defining the PER for the model. It is constructed by induction on the type
and ensures that terms which behave the same extensionally are declared equal. Values at
base types are concrete data: either trivial for values of type \AIC{`Unit} or normal
forms for values of type \AIC{`Bool}. They are considered equal when they are effectively
syntactically the same, i.e. propositionally equal. Functions on the other hand are
declared equal whenever equal inputs map to equal outputs.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{per}
\caption{Partial Equivalence Relation for Model Values\label{fig:nbeper}}
\end{figure}

On top of being a PER (i.e. symmetric and transitive), we can prove by a simple case analysis
on the type that this relation is also stable under thinning for \AF{Model} values.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{thPER}
\caption{Stability of the \AF{PER}~ under \AF{Thinning}\label{fig:nbeperth}}
\end{figure}

The interplay of reflect and reify with this notion of equality has to be described
in one go because of their mutual definition. It confirms that \AF{PER} is an appropriate
notion of semantic equality: \AF{PER}-related values are reified to propositionally
equal normal forms whilst propositionally equal neutral terms are reflected
to \AF{PER}-related values.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{reifyreflect}
\caption{Relational Versions of Reify and Reflect\label{fig:nbeperreifyreflect}}
\end{figure}

Just like in the definition of the evaluation function, conditional branching is the
interesting case. Provided a pair of boolean values (i.e. normal forms of type
\AIC{`Bool}) which are PER-equal (i.e. syntactically equal) and two pairs of PER-equal
\AB{œÉ}-values corresponding respectively to the left and right branches of the two
if-then-elses, we can prove that the two semantical if-then-else produce PER-equal values.
Because of the equality constraint on the booleans, Agda allows us to only write the
three cases we are interested in: all the other ones are trivially impossible.

In case the booleans are either \AIC{`tt} or \AIC{`ff}, we can immediately conclude
by invoking one of the hypotheses. Otherwise we remember that the evaluation function
produces a value by reflecting the neutral term obtained after reifying both branches.
We can play the same game but at the relational level this time and we obtain precisely
the proof we wanted.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{ifte}
\caption{Relational If-Then-Else\label{fig:nbeiftenelser}}
\end{figure}

This provides us with all the pieces necessary to prove our simulation lemma. The relational
counterpart of \AIC{`lam} is trivial as the induction hypothesis corresponds precisely to
the PER-notion of equality on functions. Similarly the case for \AIC{`app} is easily discharged:
the PER-notion of equality for functions is precisely the strong induction hypothesis we need
to be able to make use of the assumption that the respective function's arguments are PER-equal.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{nbe}
\caption{Normalisation by \AF{Eval}uation is in \AF{PER}-\AR{Simulation}~ with Itself\label{fig:nbeselfsim}}
\end{figure}

As a corollary, we can deduce that evaluating a term in two environments related pointwise
by \AF{PER} yields two semantic objects themselves related by \AF{PER}. Which, once reified,
give us two equal terms.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Properties/Simulation/Instances.tex]{normR}
\caption{Normalisation in \AF{PER}-related Environments Yields Equal Normal Forms}
\end{figure}

We can now move on to the more complex example of a proof framework built generically
over our notion of \AF{Semantics}.
