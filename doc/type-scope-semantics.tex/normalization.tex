\chapter{Variations on Normalisation by Evaluation}
\label{sec:variationsnormalisation}

Normalisation by Evaluation (NBE) is a technique leveraging the computational
power of a host language in order to normalise expressions of a deeply
embedded one (\cite{berger1991inverse,berger1993program,CoqDybSK,coquand2002formalised}).
The process is based on a model construction describing a family of
types by induction on its \AF{Type} index. Two
procedures are then defined: the first (\AF{eval}) constructs an element
of \AB{ùìí} \AB{œÉ} \AB{Œì} provided a well typed term of the corresponding
\AD{Term} \AB{œÉ} \AB{Œì} type whilst the second (\AF{reify}) extracts, in
a type-directed manner, normal forms \AD{Nf} \AB{œÉ} \AB{Œì} from elements
of the model \AB{ùìí} \AB{œÉ} \AB{Œì}. NBE composes the two procedures. The
definition of this \AF{eval} function is a natural candidate for our
\AF{Semantics} framework. NBE is always defined \emph{for} a
given equational theory; we start by recalling the various
rules a theory may satisfy.

\subsection{Reduction Rules}

Thanks to \AF{Renaming} and \AF{Substitution} respectively, we can formally
define Œ∑-expansion for functions and Œ≤-reduction.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Syntactic/Instances.tex]{eta}
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Syntactic/Instances.tex]{betared}
\caption{Œ∑-expansion and Œ≤-reduction in terms or \AF{th\textasciicircum{}Term} and \AF{sub}}
\end{figure}

The Œ∑-rules say that for some types, terms have a canonical form: functions will all
be Œª-headed whilst records will collect their fields -- here this makes all elements
of \AIC{\unit{}} equal to \AIC{`one}.

\begin{figure}[h]
\begin{mathpar}
\inferrule{\AB{t} ~\AS{:}~ \AD{Term}~ (\AB{œÉ} ~\AIC{`‚Üí}~ \AB{œÑ})~ \AB{Œì}
  }{\AB{t} \leadsto{} \AF{eta}~\AB{t}
  }{Œ∑_1}
\and \inferrule{\AB{t} ~\AS{:}~ \AD{Term}~ \AIC{`Unit}~ \AB{Œì}
  }{\AB{t} \leadsto{} \AIC{`one}
  }{Œ∑_2}
\and
\inferrule{
  }{\AIC{`app} ~(\AIC{`lam}~\AB{t})~ \AB{u} \leadsto \AB{t}~ \AF{‚ü®}~ \AB{u} ~\AF{/0‚ü©}
  }{Œ≤}
\end{mathpar}
\caption{Œ≤Œ∑ Rules for our Calculus\label{fig:betaetarules}}
\end{figure}

The Œ≤-rule is the main driver for actual computation,
but the presence of an inductive data type (\AIC{`Bool}) and its eliminator
(\AIC{`ifte}) means we have further redexes: whenever the
boolean the eliminator branches on is in canonical form, we may apply
a Œπ-rule. Finally, the Œæ-rule lets us reduce under
Œª-abstractions --- the distinction between weak-head normalisation and
strong normalisation.

\begin{figure}[h]
\begin{mathpar}
\inferrule{
  }{\AIC{`ifte}~\AIC{`tt}~\AB{l}~\AB{r} ~\leadsto{}~ \AB{l}
  }{Œπ_1}
\and
\inferrule{
  }{\AIC{`ifte}~\AIC{`ff}~\AB{l}~\AB{r} ~\leadsto{}~ \AB{r}
  }{Œπ_2}
\and
\inferrule{\AB{t} ~\leadsto{}~ \AB{u}
  }{\AIC{`lam}~ \AB{t} ~\leadsto{}~ \AIC{`lam}~\AB{u}
  }{Œæ}
\end{mathpar}
\caption{ŒπŒæ Rules for our Calculus\label{fig:iotaxirules}}
\end{figure}

Now that we have recalled all these rules, we can talk precisely about the
sort of equational theory decided by the model construction we choose to
perform. We start with the usual definition of NBE
which goes under Œªs and produces Œ∑-long Œ≤Œπ-short normal forms.

\subsection{Normal and Neutral Forms}

We parametrise the mutually defined inductive families \AD{Ne} and \AD{Nf}
by a predicate \AB{Eta?} constraining the types at which one may embed a neutral
as a normal form. This constraint shows up in the type of \AIC{`neu}; it makes
it possible to control whether the NBE should Œ∑-expands all terms at certain
types by prohibiting the existence of neutral terms at said type.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Syntax/Normal.tex]{normal}
\caption{Neutral and Normal Forms}
\end{figure}

Once more, the expected notions of thinning \AF{th\textasciicircum{}Ne} and
\AF{th\textasciicircum{}Nf} are induced as \AD{Ne} and \AD{Nf} are syntaxes.
We omit their purely
structural implementation here and wish we could do so in source code,
too: our constructions so far have been syntax-directed and could
surely be leveraged by a generic account of syntaxes with binding.
We will tackle this problem in~\cref{a-universe}.

\section{Normalisation by Evaluation for Œ≤ŒπŒæŒ∑}
\label{normbye}

In the case of NBE, the environment values and the computations in the model
will both use the same type family \AF{Model}, defined by induction on the
\AD{Type} argument. The Œ∑-rules allow us to represent functions (respetively
inhabitants of \AIC{`Unit}) in the source language as function spaces
(respectively values of type \AR{‚ä§}). Evaluating a \AIC{`Bool} may however
yield a stuck term so we can't expect the model to give us anything more than
an open term in normal form.

The model construction then follows the usual pattern pioneered by
Berger~(\citeyear{berger1993program}) and formally analysed and thoroughly
explained by Catarina Coquand~(\citeyear{coquand2002formalised}). We work
by induction on the type and describe Œ∑-expanded values: all inhabitants
of (\AF{Model} \AIC{`Unit} \AB{Œì}) are equal and all elements
of (\AF{Model} (\AB{œÉ} \AIC{`‚Üí} \AB{œÑ}) \AB{Œì}) are functions in Agda.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIotaXiEta.tex]{model}
\caption{Model for Normalisation by Evaluation\label{fig:nbemodel}}
\end{figure}

This model is defined by induction on the type in terms either of
syntactic objects (\AD{Nf}) or using the \AF{‚ñ°}-operator which is
a closure operator for Thinnings. As such, it is trivial to prove
that for all type \AB{œÉ}, (\AF{Model} \AB{œÉ}) is \AF{Thinnable}.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIotaXiEta.tex]{thmodel}
\caption{Values in the Model are Thinnable\label{fig:thnbemodel}}
\end{figure}

Application's semantic counterpart is easy to define: given that \AB{ùì•}
and \AB{ùìí} are equal in this instance definition we can feed the argument
directly to the function, with the identity renaming. This corresponds to
\AF{extract} for the comonad \AF{‚ñ°}.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIotaXiEta.tex]{app}
\caption{Semantic Counterpart of \AIC{`app}\label{fig:nbeapp}}
\end{figure}

Conditional branching however is more subtle: the boolean value \AIC{`if} branches on
may be a neutral term in which case the whole elimination form is stuck. This forces
us to define \AF{reify} and \AF{reflect} first. These functions, also known as quote
and unquote respectively, give the interplay between neutral terms, model values and
normal forms. \AF{reflect} performs a form of semantic Œ∑-expansion: all stuck \AIC{`Unit}
terms are equated and all functions are Œª-headed. It allows us to define \AF{var0}, the
semantic counterpart of (\AIC{`var} \AIC{z}).

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIotaXiEta.tex]{reifyreflect}
\caption{Reify and Reflect\label{fig:reifyreflectnbe}}
\end{figure}

We can then give the semantics of \AIC{`ifte}: if the boolean is a value, the
appropriate branch is picked; if it is stuck then the whole expression is stuck.
It is then turned into a neutral form by reifying the two branches and then reflected
in the model.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIotaXiEta.tex]{ifte}
\caption{Semantic Counterpart of \AIC{`ifte}\label{fig:nbeifte}}
\end{figure}

We can then combine these components. The semantics of a Œª-abstraction is simply the
identity function: the structure of the functional case in the definition of the model
matches precisely the shape expected in a \AF{Semantics}. Because the environment
carries model values, the variable case is trivial.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIotaXiEta.tex]{eval}
\caption{Evaluation is a \AR{Semantics}\label{fig:evalnbe}}
\end{figure}

We can define a normaliser by kickstarting the evaluation with an environment of
placeholder values obtained by reflecting the term's free variables and then reifying
the result.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIotaXiEta.tex]{norm}
\caption{Normalisation as Reification of an Evaluated Term\label{fig:normnbe}}
\end{figure}

\section{Normalisation by Evaluation for Œ≤ŒπŒæ}

As seen above, the traditional typed model construction leads to an NBE
procedure outputting Œ≤Œπ-normal Œ∑-long terms. However actual proof systems
rely on evaluation strategies that avoid applying Œ∑-rules
as much as possible: unsurprisingly, it is a rather bad idea to Œ∑-expand proof
terms which are already large when typechecking complex developments.

In these systems, normal forms are neither Œ∑-long nor Œ∑-short: the Œ∑-rule is
never deployed except when comparing a neutral and a constructor-headed term
for equality. Instead of declaring
them distinct, the algorithm does one step of Œ∑-expansion on the
neutral term and compares their subterms structurally. The conversion test
fails only when confronted with neutral terms with distinct head
variables or normal forms with different head constructors.

To reproduce this behaviour, NBE must be amended.
It is possible to alter the model definition described earlier so that it
avoids unnecessary Œ∑-expansions. We proceed by enriching the traditional
model with extra syntactical artefacts in a manner reminiscent of Coquand
and Dybjer's~(\citeyear{CoqDybSK}) approach to defining an NBE procedure for the SK combinator calculus. Their resorting to glueing
terms to elements of the model was dictated by the sheer impossibily to write
a sensible reification procedure but, in hindsight, it provides us with a
powerful technique to build models internalizing alternative equational
theories.

This leads us to using a predicate \AB{Eta?} which holds for all types thus allowing
us to embed all neutrals into normal forms, and to  mutually defining the model
(\AF{Model}) together with the \emph{acting} model (\AF{Value}).

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIotaXi.tex]{model}
\caption{Model Definition for Œ≤ŒπŒæ\label{nbestuckmodel}}
\end{figure}

These mutual definitions allow us to make a careful distinction between values
arising from (non expanded) stuck terms and the ones wich are constructor headed
and have a computational behaviour associated to them. The values in the acting
model are storing these behaviours be it either actual proofs of \AF{‚ä§}, actual
\AIC{`Bool}eans or actual Agda functions depending on the type of the term. It is
important to note that the functions in the acting model have the model as both
domain and codomain: there is no reason to exclude the fact that either the argument
or the body may or may not be stuck.

We have once again only used families constant in their scope index, neutral forms or
\AF{‚ñ°}-closed families. All of these are \AF{Thinnable} hence \AF{Value} and \AF{Model}
also are.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIotaXi.tex]{thmodel}
\caption{The \AF{Model} is \AF{Thinnable}}
\end{figure}

What used to be called reflection in the previous model is now trivial:
stuck terms are indeed perfectly valid model values. Reification becomes
quite straightforward too because no Œ∑-expansion is needed. When facing
a stuck term, we simply embed it in the set of normal forms. Even though
\AF{reify} may look like it is performing some Œ∑-expansions, it is not
the case: all the values in the acting model are notionally obtained
from constructor-headed terms.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIotaXi.tex]{reifyreflect}
\caption{Reflect, Reify and Interpretation for Fresh Variables}
\end{figure}

Most combinators acting on this model follow a pattern similar to their
counterpart's in the previous section. Semantic application is
more interesting: in case the function is a stuck term, we grow its
spine by reifying its argument; otherwise we have an Agda function ready
to be applied.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIotaXi.tex]{app}
\caption{Semantical Counterpart of \AIC{`app}}
\end{figure}

When defining the semantical counterpart of \AIC{`ifte}, the value case is similar to
that of the previous section: depending on the boolean value we pick either the left
or the right branch which are precisely of the right type already. If the boolean
evaluates to a stuck term, we once again reify the two branches and assemble a neutral
term. However this time we do not need to Œ∑-expand it: it is a perfectly valid inhabitant
of the \AF{Model} as is.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIotaXi.tex]{ifte}
\caption{Semantical Counterpart of \AIC{`ifte}}
\end{figure}

Finally, we have all the necessary components to show that evaluating
the term whilst not Œ∑-expanding all stuck terms is a perfectly valid
\AR{Semantics}. As usual, normalisation is defined by composing
reification and evaluation on a diagonal environment made of placeholders.

\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIotaXi.tex]{norm}

\section{Normalisation by Evaluation for Œ≤Œπ}

The decision to apply the Œ∑-rule lazily can be pushed even further: one may
forgo using the Œæ-rule too and simply perform weak-head normalisation. This
drives computation only when absolutely necessary, e.g.
when two terms compared for equality have matching head constructors
and one needs to inspect these constructors' arguments to conclude.

For that purpose, we introduce an inductive family describing terms in weak-head
normal forms.

\subsection{Weak-Head Normal Forms}

A weak-head normal form (respectively a weak-head neutral form) is a term which has
been evaluated just enough to reveal a head constructor (respectively to reach a
stuck elimination). There are no additional constraints on the subterms: a Œª-headed
term is in weak-head normal form no matter the shape of its body. Similarly an
application composed of a variable as the function and a term as the argument is in
weak-head neutral form no matter what the argument looks like. This means in particular
that unlike with \AD{Ne} and \AD{Nf} there is no mutual dependency between the definitions
of \AD{WHNE} (defined first) and \AD{WHNF}.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Syntax/WeakHead.tex]{weakhead}
\caption{Weak-Head Normal and Neutral Forms\label{fig:weakhead}}
\end{figure}

Naturally, it is possible to define the thinnings
\AF{th\textasciicircum{}WHNE} and \AF{th\textasciicircum{}WHNF} as well as erasure
functions \AF{erase\textasciicircum{}WHNE} and \AF{erase\textasciicircum{}WHNF}
with codomain \AD{Term}. We omit their simple definitions here.

\subsection{Model Construction}

The model construction is much like the previous one except
that source terms are now stored in the model too. This means that
from an element of the model, one can pick either the reduced version
of the input term (i.e. a stuck term or the term's computational
content) or the original. We exploit this ability most
notably in reification where once we have obtained either a
head constructor or a head variable, no subterm needs to
be evaluated.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIota.tex]{model}
\caption{Model Definition for Computing Weak-Head Normal Forms\label{fig:betaiotamodel}}
\end{figure}

\AF{Thinnable} can be defined rather straightforwadly based on the template provided
in the previous section: once more all the notions used in the model definition
are \AF{Thinnable} themselves. Reflection and reification also follow the same recipe
as in the previous section.


The application and conditional branching rules are more
interesting. One important difference with respect to the previous
section is that we do not grow the spine of a stuck term using
reified versions of its arguments but rather the corresponding
\emph{source} term. Thus staying true to the idea that we only head
reduce enough to expose either a constructor or a variable and let
the other subterms untouched.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIota.tex]{app}
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIota.tex]{ifte}
\caption{Semantical Counterparts of \AIC{`app} and \AIC{`ifte}\label{fig:betaiotaappifte}}
\end{figure}

The semantical counterpart of \AIC{`lam} is also slightly trickier than before. Indeed, we
need to recover the source term the value corresponds to. Luckily we know it has to be
Œª-headed and once we have introduced a fresh variable with \AIC{`lam}, we can project
out the source term of the body evaluated using this fresh variable as a placeholder
value.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/NormalisationByEvaluation/BetaIota.tex]{lam}
\caption{Semantical Counterparts of \AIC{`lam}\label{fig:betaiotalam}}
\end{figure}

We can finally put together all of these semantic counterparts to
obtain a \AR{Semantics} corresponding to weak-head normalisation.
We omit the now self-evident definition of \AF{norm\textasciicircum{}Œ≤Œπ} as the
composition of evaluation and reification.
