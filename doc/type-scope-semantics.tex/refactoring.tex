\chapter{Refactoring Common Traversals}

Once they have a good representation for their language, they will have to
(re)implement a great number of traversals doing such mundane things as
renaming, substitution, or partial evaluation. Should they want to get help
from the typechecker in order to fend off common bugs, they will have opted
for inductive families (\cite{dybjer1991inductive}) to enforce precise
invariants. But the traversals now have to be invariant preserving too!

\section{McBride's Kit}

In an unpublished manuscript, McBride~(\citeyear{mcbride2005type}) observes the
similarity between the types and implementations of renaming and substitution for
the simply typed 位-calculus (ST位C) in a dependently typed language as shown in
\cref{ren} (we focus only on \AIC{`var}, \AIC{`app}, and \AIC{`lam} for the moment).
There are three differences between the implementations of renaming and substitution:

\begin{enumerate}
  \item
    in the variable case, after renaming a variable we must wrap it
    in a \AIC{`var} constructor whereas a substitution directly
    produces a term;
  \item
    when weakening a renaming to push it under a $位$ we need only
    post-compose the renaming with the De Bruijn variable successor
    constructor \AIC{s} (which is essentially weakening for variables)
    whereas for a substitution we need a weakening operation for terms.
    It can be given by renaming via the successor constructor
    (\AF{ren} (\AIC{pack} \AIC{s}));
  \item
    also in the $位$ case, when pushing a renaming or a substitution under
    a binder we must extend it to ensure that the variable bound by the
    $位$ is mapped to itself. For renaming this involves its extension by
    the zeroth variable \AIC{z} whereas for substitutions we must extend by
    the zeroth variable seen as a term (\AIC{`var} \AIC{z}).
\end{enumerate}

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/StateOfTheArt/McBride05/Base.tex]{ren}
\ExecuteMetaData[type-scope-semantics.agda/StateOfTheArt/McBride05/Base.tex]{sub}
\caption{Renaming\label{ren} and Substitution\label{sub} for the ST$位$C}
\end{figure}

McBride then defines a notion of ``Kit'' abstracting these differences.
Rather than considering \AD{Var} and \AD{Tm} in isolation as different
types of environment values, he considers \AB{猝}, an arbitrary
(\AD{Type} \AR{Scoped}) and designs three constraints:

\begin{enumerate}
  \item
    One should be able to turn any environment value into a term of
    the same type and defined in the same scope (\ARF{var});
  \item
    One should be able to craft a fresh environment value associated
    to the zeroth variable of a scope (\ARF{zro});
  \item
    One should be able to embed environment values defined in a given
    scope into ones in a scope extended with a fresh variable (\ARF{wkn}).
\end{enumerate}

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/StateOfTheArt/McBride05/Kit.tex]{kitdef}
\caption{\AR{Kit} as a set of constraints on \AB{猝}}
\end{figure}

Whenever these constraints are met we can define a type and scope preserving
traversal which is based on an environment of \AB{猝}-values. This is the
fundamental lemma of \AR{Kit}s stated and proved in \cref{fig:kitlemma}.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/StateOfTheArt/McBride05/Kit.tex]{kitsem}
\caption{Fundamental lemma of \AR{Kit}\label{fig:kitlemma}}
\end{figure}

Thankfully, we can indeed recover renaming and substitution as two instances of
the fundamental lemma of \AR{Kit}s. We start with the \AR{Kit} for renaming
and \AF{ren} defined this time as a corollary of \AF{kit}

\begin{figure}[h]
\begin{minipage}{0.4\textwidth}
  \ExecuteMetaData[type-scope-semantics.agda/StateOfTheArt/McBride05/Kit.tex]{renkit}
\end{minipage}
\begin{minipage}{0.6\textwidth}
  \ExecuteMetaData[type-scope-semantics.agda/StateOfTheArt/McBride05/Kit.tex]{ren}
\end{minipage}
\caption{\AR{Kit} for Renaming, Renaming as a Corollary of \AF{kit}\label{fig:renkit}}
\end{figure}

Just like we needed \AF{ren} to define \AF{sub}, once we have recovered \AF{ren}
we can define the \AR{Kit} for substitution.

\begin{figure}[h]
\begin{minipage}{0.4\textwidth}
  \ExecuteMetaData[type-scope-semantics.agda/StateOfTheArt/McBride05/Kit.tex]{subkit}
\end{minipage}
\begin{minipage}{0.6\textwidth}
  \ExecuteMetaData[type-scope-semantics.agda/StateOfTheArt/McBride05/Kit.tex]{sub}
\end{minipage}
\caption{\AR{Kit} for Substitution, Substitution as a Corollary of \AF{kit}\label{fig:subkit}}
\end{figure}

\section{Opportunities for Further Generalizations}

After noticing that renaming and substitution fit the pattern, it is
natural to wonder about other traversals.

The evaluation function used in normalization by evaluation, although
not fitting \emph{exactly} in the \AR{Kit}-based approach, relies on
the same general structure. The variable case is nothing more than a
lookup in the environment; the application case is defined by combining
the results of two structural calls; and the lambda case corresponds to
the evaluation of the lambda's body in an extended context provided that
we can get a value for the newly-bound variable. Ignoring for now the
definitions of \AF{APP} and \AF{LAM}, we can see the similarities
in~\cref{nbe}.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/StateOfTheArt/McBride05/Kit.tex]{nbe}
\caption{Normalisation by Evaluation for the ST$位$C\label{nbe}}
\end{figure}

\subsection{Outline} Building on this observation, our contributions
here are twofold:

\begin{itemize}
  \item
    We generalise the ``Kit'' approach from syntax to semantics bringing
    operations like normalisation by evaluation (cf.~\cref{nbe}) but also
    printing with a name supply, or continuation passing style translation
    into our framework.

  \item
    We prove generic results about simulations between and fusions of
    semantics given by, and enabled by, Kit.
\end{itemize}

We start by introducing a notion of environments and one well known instance:
the category of renamings. This leads us to defining a generic notion of type
and scope-preserving Semantics together with a generic evaluation function.
We then showcase the ground covered by these Semantics: from the syntactic ones
corresponding to renaming and substitution to printing with names,
variations of Normalisation by Evaluation or CPS transformations.
Finally, given the generic
definition of Semantics, we can prove fundamental lemmas about these
evaluation functions: we characterise the semantics which can simulate
one another and give an abstract treatment of composition yielding
compaction and reuse of proofs compared to Benton et
al.~(\citeyear{benton2012strongly}).


\section{A Generic Notion of Environment}

All the semantics we are interested in defining associate to a term \AB{t}
of type \AD{Term} \AB{} \AB{}, a value of type \AB{} \AB{} \AB{} given
an interpretation \AB{} \AB{} {} for each one of its free variables
\AB{} in \AB{}. We call the collection of these interpretations an
\AB{}-(evaluation) environment. We leave out \AB{} when it can easily
be inferred from the context.

The content of environments may vary wildly between different semantics:
when defining renaming, the environments will carry variables whilst the
ones used for normalisation by evaluation contain elements of the model.
But their structure stays the same which prompts us to define the notion
of evaluation environment generically for any (\AB{I} \AR{Scoped}) family
of values.

Formally, this translates to \AB{}-environments being the
pointwise lifting of the relation \AB{} between contexts and types to a
relation between two contexts. Rather than using a datatype to represent
such a lifting, we choose to use a function space. This decision is based
on Jeffrey's observation~(\citeyear{jeffrey2011assoc}) that one can obtain
associativity of append for free by using difference lists. In our case the
interplay between various combinators (e.g. \AF{identity} and \AF{select})
defined later on is vastly simplified by this rather simple decision.

\begin{figure}[h]
\ExecuteMetaData[shared/Data/Environment.tex]{env}
\caption{Generic Notion of Environment\label{fig:env}}
\end{figure}

These environments naturally behave like the contexts they are indexed by:
there is a trivial environment for the empty context and one can easily
extend an existing one by providing an appropriate value. The packaging of
the function representing to the environment in a record allows for two
things: it helps the typechecker by stating explicitly which type family
the values correspond to and it empowers us to define environments by
copattern-matching (\cite{abel2013copatterns}) thus defining environments
by their use cases.

\label{fig:envcombinators}

The definition of the empty environment uses an absurd match (\AS{()}): given
the definition of \AD{Var} in \cref{fig:variable}, it should be pretty clear
that there can never be a value of type ({\AD{Var} \AB{} \AIC{[]}}).

\begin{figure}[h]
\ExecuteMetaData[shared/Data/Environment.tex]{empty}
\caption{Empty Environment\label{fig:emptyenv}}
\end{figure}

The environment extension definition proceeds by pattern-matching on the
variable: if it \AIC{z} then we return the newly-added value, otherwise we are
referring to a value in the original environment and can simply look it up.

\begin{figure}[h]
\ExecuteMetaData[shared/Data/Environment.tex]{extension}
\caption{Environment Extension\label{fig:envextend}}
\end{figure}

\subsection{The Category of Thinnings}
\label{sec:categoryrenamings}

A key instance of environments playing a predominant role in this paper is the
notion of thinning. The reader may be accustomed to the more restrictive notion
of renamings as described variously as Order Preserving Embeddings
(\cite{chapman2009type}), thinnings (which we use), context inclusions,
or just weakenings (\cite{altenkirch1995categorical}). A thinning
(\AF{Thinning} \AB{} \AB{}) is an environment pairing each variable
of type \AB{} in \AB{} to one of the same type in \AB{}.

\begin{figure}[h]
\ExecuteMetaData[shared/Data/Environment.tex]{thinning}
\caption{Thinnings: A Special Case of Environments\label{fig:thinnings}}
\end{figure}

Writing non-injective or non-order preserving renamings would take perverse effort
given that we only implement generic interpretations. In practice, although the type
of thinnings is more generous, we only introduce weakenings (skipping variables at
the beginning of the context) that become thinnings (skipping variables at arbitrary
points in the context) when we push them under binders. The extra flexibility will not
get in our way, and permits a representation as a function space which grants us monoid
laws ``for free'' as per Jeffrey's observation (\citeyear{jeffrey2011assoc}).

These simple observations allow us to prove that thinnings form a category which,
in turn, lets us provide the user with the constructors Altenkirch, Hofmann and
Streicher's ``Category of Weakening"~(\citeyear{altenkirch1995categorical}) is based on.

\begin{figure}[h]
\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[shared/Data/Environment.tex]{identity}
\end{minipage}\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[shared/Data/Environment.tex]{extend}
\end{minipage}

\ExecuteMetaData[shared/Data/Environment.tex]{select}
\caption{Examples of Thinning Combinators\label{fig:extendth}}
\end{figure}

The \AF{} combinator turns any (\AD{List} \AB{I})-indexed Set into one that can
absorb thinnings. This is accomplished by abstracting over all possible thinnings
from the current scope, akin to an S4-style necessity modality. The axioms of S4
modal logic incite us to observe that the functor \AF{} is a comonad: \AF{extract}
applies the identity \AF{Thinning} to its argument, and \AF{duplicate} is obtained
by composing the two \AF{Thinning}s we are given (\AF{select} defined in
\cref{fig:extendth} corresponds to transitivity in the special case where \AB{}
is \AD{Var}). The expected laws hold trivially thanks to Jeffrey's trick mentioned above.

\begin{figure}[h]
\ExecuteMetaData[shared/Data/Environment.tex]{box}
\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[shared/Data/Environment.tex]{extract}
\end{minipage}\begin{minipage}{0.5\textwidth}
\ExecuteMetaData[shared/Data/Environment.tex]{duplicate}
\end{minipage}
\caption{The \AF{} Functor is a Comonad}
\end{figure}

The notion of \AF{Thinnable} is the property of being stable under thinnings;
in other words \AF{Thinnable}s are the coalgebras of \AF{}.
It is a crucial property for values to have if one wants to be able to push
them under binders. From the comonadic structure we get that
the \AF{} combinator freely turns any (\AD{List} I)-indexed Set into a
\AF{Thinnable} one.

\begin{figure}[h]
\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[shared/Data/Environment.tex]{thinnable}
\end{minipage}\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[shared/Data/Environment.tex]{thBox}
\end{minipage}
\caption{Thinning Principle and the Cofree Thinnable \AF{}\label{fig:thinnable}}
\end{figure}

Constant families are trivially \AF{Thinnable}. In the case of variables,
thinning merely corresponds to applying the renaming function in order to
obtain a new variable. The environments' case is also quite simple: being
a pointwise lifting of a relation \AB{} between contexts and types, they
enjoy thinning if \AB{} does.

\begin{figure}[h]
\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[shared/Data/Environment.tex]{thConst}
\end{minipage}\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[shared/Data/Environment.tex]{thVar}
\end{minipage}

\ExecuteMetaData[shared/Data/Environment.tex]{thEnv}
\caption{Thinnable Instances for Variables and Environments\label{fig:thinVarEnv}}
\end{figure}

Now that we are equipped with the notion of inclusion, we have all
the pieces necessary to describe the Kripke structure of our models
of the simply typed 位-calculus.

\section{Semantics and Their Generic Evaluators}
\label{section:generic-semantics}

The upcoming sections demonstrate that renaming, substitution, and printing with
names all share the same structure. We start by abstracting away a notion of
\AR{Semantics} encompassing all these constructions. This approach will make it
possible for us to implement a generic traversal parametrised by such a
\AR{Semantics} once and for all and to focus on the interesting model constructions
instead of repeating the same pattern over and over again.

Broadly speaking, a semantics turns our deeply embedded abstract syntax trees
into the shallow embedding of the corresponding parametrised higher order abstract
syntax term (\cite{chlipala2008parametric}). We get a choice of useful type-and-scope
safe traversals by using different `host languages' for this shallow embedding.

A semantics is parametrised by two (\AD{Type} \AR{Scoped}) type families \AB{}
and \AB{}. Realisation of a semantics will produce a computation in \AB{} for every
term whose variables are assigned values in \AB{}. Just as an environment interprets
variables in a model, a computation gives a meaning to terms into a model. We can
define \AF{Comp} to make this parallel explicit.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Specification.tex]{comp}
\caption{Generic Notion of Computation\label{fig:comp}}
\end{figure}

An appropriate notion of semantics for the calculus is one that will map environments
to computations. In other words, a set of constraints on $$ and $$ guaranteeing
the existence of a function of type
((\AB{} \AR{Env}) \AB{} \AB{} \AS{} (\AB{} \AF{Comp}) \AB{} \AB{}).
In cases such as substitution or normalisation by evaluation, \AB{} and \AB{} will
happen to coincide but keeping these two relations distinct is precisely what makes
it possible to go beyond these and also model renaming or printing with names.

Concretely, we define \AR{Semantics} as a record packing the properties these families
need to satisfy for the evaluation function to exist.

\ExecuteMetaData[type-scope-semantics.agda/Semantics/Specification.tex]{recsem}

The first method of a \AR{Semantics} deals with environment values. They
need to be thinnable (\ARF{th\textasciicircum{}}) so that the traversal
may introduce fresh variables when going under a binder whilst keeping
the environment well-scoped.

\ExecuteMetaData[type-scope-semantics.agda/Semantics/Specification.tex]{thV}

The structure of the model is quite constrained: each constructor
in the language needs a semantic counterpart. We start with the
two most interesting cases: \ARF{var} and \ARF{lam}. The variable
case bridges the gap between the fact that the environment translates
variables into values \AB{} but the evaluation function returns
computations \AB{}.

\ExecuteMetaData[type-scope-semantics.agda/Semantics/Specification.tex]{var}

The semantic 位-abstraction is notable for two reasons: first, following
Mitchell and Moggi~(\citeyear{mitchell1991kripke}), its \AF{}-structure is
typical of models  la Kripke allowing arbitrary extensions of the context;
and second, instead of being a function in the host language taking
computations to computations,  it takes \emph{values} to computations.
This is concisely expressed by the type ({\AF{} (\AB{}~\AB{} \AF{} \AB{}~\AB{})}).

It matches precisely the fact that the body of a 位-abstraction exposes
one extra free variable, prompting us to extend the environment with a
value for it. In the special case where \AB{} = \AB{} (normalisation
by evaluation for instance), we recover the usual Kripke structure.

\ExecuteMetaData[type-scope-semantics.agda/Semantics/Specification.tex]{lam}

The remaining fields' types are a direct translation of the types of the
constructor they correspond to: substructures have simply been replaced with
computations thus making these operators ideal to combine induction hypotheses.
For instance, the semantical counterpart of application is an operation that
takes a representation of a function and a representation of an argument and
produces a representation of the result.

\ExecuteMetaData[type-scope-semantics.agda/Semantics/Specification.tex]{cons}

The type we chose for \ARF{lam} makes the \AF{Semantics} notion powerful enough that
even logical predicates are instances of it. And we indeed exploit this power when
defining normalisation by evaluation as a semantics: the model construction is, after
all, nothing but a logical predicate. As a consequence it seems rather natural to call
\AF{semantics} ``the fundamental lemma of semantics''. We prove it in a module parametrised
by a \AF{Semantics}, which would correspond to using a Section in Coq. It is defined by
structural recursion on the term. Each constructor is replaced by its semantic counterpart
which combines the induction hypotheses for its subterms.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Specification.tex]{fundamental}
\caption{Fundamental Lemma of \AR{Semantics}\label{fig:fundsem}}
\end{figure}

\section{Syntax Is the Identity Semantics}
\label{sec:syntactic}

As we have explained earlier, this work has been directly influenced by
McBride's ~(\citeyear{mcbride2005type}) manuscript. It seems appropriate
to start our exploration of \AR{Semantics} with the two operations he
implements as a single traversal. We call these operations syntactic
because the computations in the model are actual terms and almost all term
constructors are kept as their own semantic counterpart. As observed by
McBride, it is enough to provide three operations describing the properties
of the values in the environment to get a full-blown \AR{Semantics}. This
fact is witnessed by our simple \AR{Syntactic} record type together with
the fundamental \AF{lemma} of \AR{Syntactic}, a function turning its
inhabitants into associated \AR{Semantics}.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Syntactic/Specification.tex]{syntactic}
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Syntactic/Specification.tex]{syntacticsem}
\caption{Every \AR{Syntactic} gives rise to a \AR{Semantics}\label{fig:syntactic}}
\end{figure}

The shape of \ARF{lam} or \ARF{one} should not trick the reader
into thinking that this definition performs some sort of 畏-expansion:
the fundamental \AF{lemma} indeed only ever uses one of these when the
evaluated term's head constructor is already respectively a \AIC{`lam}
or a \AIC{`one}. It is therefore absolutely possible to define renaming
or substitution using this approach. We can now port McBride's definitions
to our framework.


\subsection{Functoriality, also known as Renaming}

Our first example of a \AR{Syntactic} operation works with variables as
environment values. We have already defined thinning earlier (see
\cref{sec:categoryrenamings}) and we can turn a variable into a term by using
the \AIC{`var} constructor. The type of \AF{sem} specialised to this
semantics is then precisely the proof that terms are thinnable.

\begin{figure}[h]
\begin{minipage}{0.5\textwidth}
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Syntactic/Instances.tex]{synren}
\end{minipage}\begin{minipage}{0.5\textwidth}
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Syntactic/Instances.tex]{ren}
\end{minipage}
\caption{Thinning as a \AR{Syntactic} Instance\label{fig:synren}}
\end{figure}

\subsection{Simultaneous Substitution}

Our second example of a semantics is another spin on the syntactic model:
environment values are now terms. We get thinning for terms from the
previous example. Again, specialising the type of \AF{sem}
reveals that it delivers precisely the simultaneous substitution.

\begin{figure}[h]
\begin{minipage}{0.4\textwidth}
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Syntactic/Instances.tex]{synsub}
\end{minipage}\begin{minipage}{0.6\textwidth}
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Syntactic/Instances.tex]{sub}
\end{minipage}
\caption{Parallel Substitution as a \AR{Syntactic} Instance\label{fig:synsub}}
\end{figure}

\section{Printing with Names}
\label{prettyprint}

Before considering the various model constructions involved in defining
normalisation functions deciding different equational theories, let us
make a detour to a perhaps slightly more surprising example of a
\AF{Semantics}: printing with names. A user-facing project would naturally
avoid directly building a \AD{String} and rather construct an inhabitant of
a more sophisticated datatype in order to generate a prettier output
(\cite{hughes1995design,wadler2003prettier,Bernardy:2017:PBG:3136534.3110250}).
But we stick to the simpler setup as \emph{pretty} printing is not our focus here.

This example is interesting for two reasons. Firstly, the distinction between
values and computations is once more instrumental: we get to give the procedure
a precise type guiding our implementation. The environment carries \emph{names}
for the variables currently in scope whilst the computations thread a name-supply
(a stream of strings) to be used to generate fresh names for bound variables
(here we use \AF{M} for the state monad threading that name supply).
If the values in the environment had to be computations too, we would not root
out some faulty implementations e.g a program picking a new name each time a
variable is mentioned.

\begin{figure}[h]
\begin{minipage}{0.5\textwidth}
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Printing.tex]{name}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Printing.tex]{printer}
\end{minipage}
\caption{Names and Printer for the Printing Semantics\label{fig:semprint}}
\end{figure}

Secondly, the fact that the model's computation type is a monad and that this
poses no problem whatsoever in this framework means it is appropriate for
handling languages with effects (\cite{moggi1991notions}), or effectful
semantics e.g. logging the various function calls. Here is the full definition
of the printer.

\ExecuteMetaData[type-scope-semantics.agda/Semantics/Printing.tex]{printingdef}

Because the output type is not scoped in any way, thinning for \AF{Name}s
(\ARF{th\textasciicircum{}}) is trivial: we return the same name. The variable
case (\ARF{var}) is a bit more interesting: after looking up a variable's \AF{Name}
in the environment, we use \AF{return} to produce the trivial \AF{Printer} constantly
returning that name.

\ExecuteMetaData[type-scope-semantics.agda/Semantics/Printing.tex]{printingvar}

As often, the case for 位-abstraction (\ARF{lam}) is the most interesting one.
We first use \AF{fresh} to generate a \AF{Name} for the newly-bound variable,
then run the printer for the body in the environment extended with that fresh
name and finally build a string combining the name and the body together.

\ExecuteMetaData[type-scope-semantics.agda/Semantics/Printing.tex]{printinglam}

We then have a collection of base cases for the data constructors of type
\AIC{`Unit} and \AIC{`Bool}. These give rise to constant printers.

\ExecuteMetaData[type-scope-semantics.agda/Semantics/Printing.tex]{printingcons}

Finally we have purely structural cases: we run the printers for each of~
the subparts and put the results together, throwing in some extra parenthesis~
to guarantee that the result is unambiguous.

\ExecuteMetaData[type-scope-semantics.agda/Semantics/Printing.tex]{printingstruct}


The fundamental \AF{lemma} of \AR{Semantics} will deliver a printer which needs to be run
on a \AD{Stream} of distinct \AD{String}s. Our definition of \AF{names} (not
shown here) simply cycles through the letters of the alphabet and guarantees
uniqueness by appending a natural number incremented each time we are back at
the beginning of the cycle. This crude name generation strategy would naturally
be replaced with a more sophisticated one in a user-facing language: we could
e.g. use naming hints for user-introduced binders and type-based schemes otherwise
($f$ or $g$ for functions, $i$ or $j$ for integers, etc.).

In order to kickstart the evaluation, we still need to provide \AR{Name}s
for each one of the free variables in scope. We deliver that environment
by a simple stateful computation \AF{init} chopping off an initial segment
of the name supply of the appropriate length. We can define it using \AF{sequenceA}
because environments are traversable (\cite{mcbride_paterson_2008}).
The definition of \AF{print} follows.

\begin{figure}[h]
\begin{minipage}{0.5\textwidth}
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Printing.tex]{init}
\end{minipage}\begin{minipage}{0.5\textwidth}
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Printing.tex]{printerfun}
\end{minipage}

\ExecuteMetaData[type-scope-semantics.agda/Semantics/Printing.tex]{print}
\caption{Printer\label{fig:printer}}
\end{figure}

We can observe \AF{print}'s behaviour by writing a test; we state it as a
propositional equality and prove it using \AIC{refl}, forcing the typechecker
to check that both expressions indeed compute to the same normal form. Here
we display the identity function defined in a context of size 2. As we can see,
the binder receives the name \AStr{"c"} because \AStr{"a"} and \AStr{"b"} have
already been assigned to the free variables in scope.

\begin{figure}[h]
\ExecuteMetaData[type-scope-semantics.agda/Semantics/Printing.tex]{test}
\caption{Printing an Open Term\label{fig:printtest}}
\end{figure}
