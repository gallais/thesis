\chapter{Introduction to Martin L\"of Type Theory via Agda}

The techniques and abstractions defined in this thesis are language-independent: all the
results can be replicated in any Martin L\"of Type Theory equipped with inductive
families~(\cite{dybjer1994inductive}). In practice, all of the content of this thesis
has been formalised in Agda~(\cite{norell2009dependently}) so we provide a (brutal)
introduction to dependently-typed programming in Agda.

\section{(Co)Data and (co)pattern matching}

\ExecuteMetaData[introduction.agda/introduction.tex]{nat}

record types: (+ available projections)

\ExecuteMetaData[introduction.agda/introduction.tex]{unit}
\ExecuteMetaData[introduction.agda/introduction.tex]{pair}

Definitions by pattern matching: large elimination

\ExecuteMetaData[introduction.agda/introduction.tex]{ntuple}


Definition by pattern matching; types are refined in each branch

\ExecuteMetaData[introduction.agda/introduction.tex]{replicate}
\ExecuteMetaData[introduction.agda/introduction.tex]{mapntuple}

Dependent records

\ExecuteMetaData[introduction.agda/introduction.tex]{maptuple}

In Agda, as in all functional programming languages, we can define anonymous functions
by using a \AS{λ}-abstraction. Additionally, we can define anonymous (co)pattern-matching
functions by using (\AS{λ} \AK{where}) followed by an indented block of clauses.


\ExecuteMetaData[introduction.agda/introduction.tex]{maptuple}

\section{Sized Types and Termination Checking}

If we naïvely define rose trees containing \AB{A} values as either a \AIC{leaf} storing
a value of type \AB{A} or a \AIC{node} of a \AR{Tuple} of rose trees then we quickly
realise that we cannot re-use higher order functions on \AR{Tuple} to define recursive
functions on \AD{Rose}. As an example, let us consider \AF{map\textasciicircum{}Rose}.
In the \AIC{node} case, the termination checker does not realise that the partially
applied recursive call (\AF{map\textasciicircum{}Rose} \AB{f}) passed to
\AF{map\textasciicircum{}Tuple} will only ever be used on subterms.

\ExecuteMetaData[introduction.agda/introduction.tex]{rose}
\ExecuteMetaData[introduction.agda/introduction.tex]{maprose}

The usual solution to this issue is to remove the level of indirection introduced by
the calll to \AF{map\textasciicircum{}Tuple} by mutually defining with
\AF{map\textasciicircum{}Rose} an inlined version of
(\AF{map\textasciicircum{}Tuple} (\AF{map\textasciicircum{}Rose} \AB{f})).

\ExecuteMetaData[introduction.agda/introduction.tex]{inlinedmaprose}

This is, of course, not at all satisfactory.
With sized types no need to inline higher order function\todo{fix}

\ExecuteMetaData[introduction.agda/introduction.tex]{erose}
\ExecuteMetaData[introduction.agda/introduction.tex]{maperose}

In practice we make the size argument explicit in the type but implicit in the
constructors

\ExecuteMetaData[introduction.agda/introduction.tex]{irose}
\ExecuteMetaData[introduction.agda/introduction.tex]{mapirose}

\section{Combinators}

On top of the constructs provided by the language itself, we can define various
domain specific languages (DSL) which give us the means to express ourselves
concisely.

\subsection{Working with Indexed Families}
\label{indexed-combinators}

We are going to manipulate a lot of indexed families so we give ourselves a few
combinators corresponding to the typical operations we want to perform on them.
\todo{extract from generic-syntax}

\ExecuteMetaData[shared/Stdlib.tex]{implication}
\ExecuteMetaData[shared/Stdlib.tex]{forall}
\ExecuteMetaData[shared/Stdlib.tex]{update}
