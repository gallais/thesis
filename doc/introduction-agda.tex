\chapter{Introduction to Agda}

The techniques and abstractions defined in this thesis are language-independent: all the
results can be replicated in any Martin L\"of Type Theory equipped with inductive
families~(\cite{dybjer1994inductive}). In practice, all of the content of this thesis
has been formalised in Agda~(\cite{norell2009dependently}) so we provide a (brutal)
introduction to dependently-typed programming in Agda.

\section{(Co)Data and (co)pattern matching}

As is customary, we start our introduction to dependently-typed programming by
defining the natural numbers. They are defined as an inductive type with two
conctructors: \AIC{zero} and \AIC{suc}cessor.

\ExecuteMetaData[introduction.agda/introduction.tex]{nat}

We can also define record types

record types: (+ available projections)

\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[introduction.agda/introduction.tex]{unit}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\ExecuteMetaData[introduction.agda/introduction.tex]{pair}
\end{minipage}

Definitions taking values of an inductive type as argument are defined by
pattern matching in a style familiar to Haskell programmers: one lists
clauses assuming a first-match semantics. If the patterns on the left hand
side are covering all possible cases and the recursive calls are structurally
recursive, the function is total.

The main difference with Haskell is that in Agda, we can perform so-called
``large elimination'': we can define a \AS{Set} by pattern-matching on a
piece of data. Here we use our unit and pair records to define a tuple of
size \AB{n} by recursion over \AB{n}.

\ExecuteMetaData[introduction.agda/introduction.tex]{ntuple}

Because types can now depend on the shape of values, in a definition by pattern
matching each clause has a type \emph{refined} based on the patterns which appear
on the left hand side. This will be a familiar for Haskell programmers used to
manipulating Generalized Algebraic Data Types (GADTs). Let us see two examples of
a type being refined based on the pattern appearing in a clause.

First, the return type of \AF{replicate} reduces to \AR{⊤} when the natural
number is \AIC{zero} and (\AB{A} \AR{×} (\AF{replicate} \AB{n} \AB{A})) when it is
(\AIC{suc} \AB{n}).

\ExecuteMetaData[introduction.agda/introduction.tex]{replicate}

Second, both the type of the \AF{-Tuple} argument and the \AF{-Tuple} return type
are refined based on the patterns the natural number matches. In the second clause,
this tells us the \AF{-Tuple} argument is a pair, allowing us to match on it with
the pair constructor \AIC{\_,\_}.

\ExecuteMetaData[introduction.agda/introduction.tex]{mapntuple}

Dependent records

\ExecuteMetaData[introduction.agda/introduction.tex]{tuple}

In Agda, as in all functional programming languages, we can define anonymous functions
by using a \AS{λ}-abstraction. Additionally, we can define anonymous (co)pattern-matching
functions by using (\AS{λ} \AK{where}) followed by an indented block of clauses.

\ExecuteMetaData[introduction.agda/introduction.tex]{maptuple}

\section{Sized Types and Termination Checking}

If we naïvely define rose trees containing \AB{A} values as either a \AIC{leaf} storing
a value of type \AB{A} or a \AIC{node} of a \AR{Tuple} of rose trees then we quickly
realise that we cannot re-use higher order functions on \AR{Tuple} to define recursive
functions on \AD{Rose}. As an example, let us consider \AF{map\textasciicircum{}Rose}.
In the \AIC{node} case, the termination checker does not realise that the partially
applied recursive call (\AF{map\textasciicircum{}Rose} \AB{f}) passed to
\AF{map\textasciicircum{}Tuple} will only ever be used on subterms. We need to use
an unsafe \AK{TERMINATING} pragma to force Agda to accept the definition.

\ExecuteMetaData[introduction.agda/introduction.tex]{rose}
\ExecuteMetaData[introduction.agda/introduction.tex]{maprose}

This is not at all satisfactory: we do not want to give up safety to write such a
simple traversal. The usual solution to this issue is to remove the level of
indirection introduced by the calll to \AF{map\textasciicircum{}Tuple} by mutually
defining with \AF{map\textasciicircum{}Rose} an inlined version of
(\AF{map\textasciicircum{}Tuple} (\AF{map\textasciicircum{}Rose} \AB{f})).

\ExecuteMetaData[introduction.agda/introduction.tex]{inlinedmaprose}

This is, of course, still unsatisfactory: we need to duplicate code every
time we want to write a traversal! By using sized types, we can have a more
compositional notion of termination checking: the size of a term is reflected
in its type. No matter how many levels of indirection there are between the
location where we are peeling off a constructor and the place where the function
is actually called recursively, as long as the intermediate operations are
size-preserving we know that the recursive call will be legitimate.

Writing down the sizes explicitly, we get the following implementation. Note
that in (\AF{map\textasciicircum{}Tuple} (\AF{map\textasciicircum{}Rose} \AB{j} \AB{f})),
\AB{j} (bound in \AIC{node}) is smaller than \AB{i} and therefore the recursive
call is justified.

\ExecuteMetaData[introduction.agda/introduction.tex]{erose}
\ExecuteMetaData[introduction.agda/introduction.tex]{maperose}

In practice we make the size arguments explicit in the types but implicit in the
terms. This leads to programs that look just like our ideal implementation, with
the added bonus that we have now \emph{proven} the function to be total.

\ExecuteMetaData[introduction.agda/introduction.tex]{irose}
\ExecuteMetaData[introduction.agda/introduction.tex]{mapirose}

\section{Combinators}

On top of the constructs provided by the language itself, we can define various
domain specific languages (DSL) which give us the means to express ourselves
concisely.

\subsection{Working with Indexed Families}
\label{indexed-combinators}

We are going to manipulate a lot of indexed families so we give ourselves a few
combinators corresponding to the typical operations we want to perform on them.
\todo{extract from generic-syntax}

\ExecuteMetaData[shared/Stdlib.tex]{implication}
\ExecuteMetaData[shared/Stdlib.tex]{forall}
\ExecuteMetaData[shared/Stdlib.tex]{update}
