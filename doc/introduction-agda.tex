\chapter{Introduction to Martin L\"of Type Theory via Agda}

\section{(Co)Data and (co)pattern matching}

\ExecuteMetaData[introduction.agda/introduction.tex]{nat}

record types: (+ available projections)

\ExecuteMetaData[introduction.agda/introduction.tex]{unit}
\ExecuteMetaData[introduction.agda/introduction.tex]{pair}

Definitions by pattern matching: large elimination

\ExecuteMetaData[introduction.agda/introduction.tex]{ntuple}

Definition by pattern matching; types are refined in each branch

\ExecuteMetaData[introduction.agda/introduction.tex]{replicate}
\ExecuteMetaData[introduction.agda/introduction.tex]{mapntuple}

Dependent records

\ExecuteMetaData[introduction.agda/introduction.tex]{maptuple}

Pattern matching lambda with copatterns

\ExecuteMetaData[introduction.agda/introduction.tex]{maptuple}

\section{Sized Types and Termination Checking}

With sized types no need to inline higher order function

\ExecuteMetaData[introduction.agda/introduction.tex]{erose}
\ExecuteMetaData[introduction.agda/introduction.tex]{maperose}

In practice we make the size argument explicit in the type but implicit in the
constructors

\ExecuteMetaData[introduction.agda/introduction.tex]{irose}
\ExecuteMetaData[introduction.agda/introduction.tex]{mapirose}

\section{Combinators}

On top of the constructs provided by the language itself, we can define various
domain specific languages (DSL) which give us the means to express ourselves
concisely.

\subsection{Working with Indexed Families}
\label{indexed-combinators}

We are going to manipulate a lot of indexed families so we give ourselves a few
combinators corresponding to the typical operations we want to perform on them.
\todo{extract from generic-syntax}

\ExecuteMetaData[shared/Stdlib.tex]{implication}
\ExecuteMetaData[shared/Stdlib.tex]{forall}
\ExecuteMetaData[shared/Stdlib.tex]{update}
