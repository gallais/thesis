\chapter{Introduction to Agda}

The techniques and abstractions defined in this thesis are language-independent:
all the results can be replicated in any Martin L\"of Type Theory
(\citeyear{martin1982constructive}) equipped with inductive
families~(\cite{dybjer1994inductive}). In practice, all of the content of this
thesis has been formalised in Agda~(\cite{norell2009dependently}) so we provide a (brutal)
introduction to dependently-typed programming in Agda. It is a dependently typed
programming language based on Martin-L\"{o}f Type Theory with inductive families,
induction-recursion (\cite{Dybjer1999}), copattern-matching
(\cite{abelPientkaThibodeauSetzer:popl13}) and sized types
(\cite{DBLP:journals/corr/abs-1012-4896}).

\section{Set and Universe Levels}

Agda is both a dependently typed programming language and a proof assistant.
As such, its type system needs to be sound. A direct consequence is that the
type of all types cannot itself be a type. This is solved by using a stratified
tower of universes.

\begin{feature}[Universe Levels]
Agda avoids Russell-style paradoxes by introducing a tower of universes
\AF{Set₀} (usually written \AF{Set}), \AF{Set₁}, \AF{Set₂}, etc. Each
\AF{Setₙ} does not itself have type \AF{Setₙ} but rather \AF{Setₙ₊₁} thus
preventing circularity.
\end{feature}

In practice most of our constructions will stay at the lowest level \AF{Set}
(commonly called the ``type of small sets''), and we will only occasionally
mention \AF{Set₁}. The barest of examples involving both notions is the
following definition of \AF{ID}, the (large) type of the identity function on
small sets, together with \AF{id} the corresponding identity function.

\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[introduction.agda/introduction.tex]{idType}
\end{minipage}\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[introduction.agda/introduction.tex]{idTerm}
\end{minipage}

In the type \AF{ID} we wrapped the \AF{Set} argument using curly braces.
This is our way of telling Agda that this argument should be easy to figure
out and that we do not want to have to write it explicitly every time we
call \AF{id}.

\begin{feature}[Implicit Arguments]
Programmers can mark some of a function's arguments as implicit by
wrapping them in curly braces. The values of these implicit arguments
can be left out at the function's call sites and Agda will reconstruct
them by unification~(\cite{DBLP:conf/tlca/AbelP11}).
\end{feature}

\section{Data and (co)pattern matching}

\paragraph{Sum Types} Agda supports inductive families
(\cite{dybjer1991inductive}), a generalisation of the algebraic data types
one can find in most functional programming languages. The plainest of sum
types is the type of boolean values. We define it as the datatype with two
constructors \AIC{true} and \AIC{false}. The function \AF{if\_then\_else\_}
is defined by pattern-matching on the boolean value.

\begin{minipage}{0.35\textwidth}
  \ExecuteMetaData[introduction.agda/introduction.tex]{bool}
\end{minipage}\begin{minipage}{0.65\textwidth}
  \ExecuteMetaData[introduction.agda/introduction.tex]{ifte}
\end{minipage}

\begin{feature}[Mixfix Identifiers] We use Agda's mixfix operator notation
(\cite{danielsson2011parsing}) where underscores denote argument positions.
This empowers us to define the \AF{if\_then\_else\_} construct rather than
relying on it being built in like in so many other languages. For another
example, at the type-level this time, see e.g. the notation \AR{\_×\_} for
the type of pairs defined in \cref{par:recordtypes}.
\end{feature}

\begin{feature}[Syntax Highlighting] We rely on Agda's \LaTeX{} backend to produce
syntax highlighting for all the code fragments in this thesis. The convention
is as follows: keywords are highlighted in \AK{orange}, data constructors in
\AIC{green}, record fields in \ARF{pink}, types and functions in \AD{blue}
while bound variables are \AB{black}.
\end{feature}

\paragraph{Inductive Types}

As is customary, our first inductive type will be the natural numbers.
They are defined as an inductive type with two constructors: \AIC{zero}
and \AIC{suc}cessor.

\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[introduction.agda/introduction.tex]{nat}
\end{minipage}\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[introduction.agda/introduction.tex]{add}
\end{minipage}

\begin{feature}[Termination Checking](\cite{abel1998foetus})
\end{feature}

\paragraph{Record Types}\label{par:recordtypes}

Agda also supports record types; they are defined by their list of fields.
Unlike inductive types they enjoy η-rules. That is to say that any two
values of the same record type are judgmentally equal whenever all of their
fields' values are.

We define the unit type (\AR{⊤}) which has one constructor (\AIC{tt}) but no
field. As a consequence, the η-rule for \AR{⊤} states that any two values of
the unit type are equal to each other. This is demonstrated by the equality
proof we provide.

\begin{minipage}[t]{0.5\textwidth}
  \ExecuteMetaData[introduction.agda/introduction.tex]{unit}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
\ExecuteMetaData[introduction.agda/introduction.tex]{uniteq}
\end{minipage}

\begin{feature}[Underscore as Placeholder Name]
An underscore used in place of an identifier in a binder means that the binding
should be discarded. For instance {(\AS{λ} \_ \AS{→} a)} defines a constant function.
Toplevel bindings can similarly be discarded which is a convenient way of
writing unit tests (in type theory programs can be run at typechecking time)
without polluting the namespace.
\end{feature}

ogether with the pair type \AR{\_×\_} which has an infix constructor
\AIC{\_,\_} and two fields: its first (\ARF{fst}) and second (\ARF{snd})
projections.

\ExecuteMetaData[introduction.agda/introduction.tex]{pair}

Defining a record type \AR{R} also results in the definition of a module \AB{R}
parametrised by a value of type \AR{R} and containing a projection function
for each field. We can \AK{open} it to make these projections available to the
outside world, or use \AB{R}-qualified names. Projections may be used prefix
or suffix (in which case one needs to add a dot).

\begin{minipage}{0.5\textwidth}
  \ExecuteMetaData[introduction.agda/introduction.tex]{duplicate}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\ExecuteMetaData[introduction.agda/introduction.tex]{swap}
\end{minipage}

\begin{feature}[Implicit Generalisation] The latest version of Agda supports ML-style
implicit prenex polymorphism and we make heavy use of it: every unbound variable
should be considered implicitly bound at the beginning of the telescope. In the above
example, \AB{A} and \AB{B} are introduced using this mechanism.
\end{feature}

\paragraph{Recursive Functions}

Definitions taking values of an inductive type as argument are defined by
pattern matching in a style familiar to Haskell programmers: one lists
clauses assuming a first-match semantics. If the patterns on the left hand
side are covering all possible cases and the recursive calls are structurally
smaller, the function is total. All definitions have to be total in Agda.

The main difference with Haskell is that in Agda, we can perform so-called
``large elimination'': we can define a \AF{Set} by pattern-matching on a
piece of data. Here we use our unit and pair records to define a tuple of
size \AB{n} by recursion over \AB{n}: a (\AIC{zero} \AF{-Tuple}) is empty
whilst a (\AIC{suc n} \AF{-Tuple}) is a value paired with an (\AB{n} \AF{-Tuple}).

\ExecuteMetaData[introduction.agda/introduction.tex]{ntuple}

Because types can now depend on the shape of values, in a definition by pattern
matching each clause has a type \emph{refined} based on the patterns which appear
on the left hand side. This will be familiar to Haskell programmers used to
manipulating Generalized Algebraic Data Types (GADTs). Let us see two examples of
a type being refined based on the pattern appearing in a clause.

First, we introduce \AF{replicate} which takes a natural number \AB{n} and a value
\AB{a} of type \AB{A} and returns an (\AB{n} \AF{-Tuple}) by duplicating \AB{a}.
The return type of \AF{replicate} reduces to \AR{⊤} when the natural number is
\AIC{zero} and (\AB{A} \AR{×} (\AB{n} \AF{-Tuple} \AB{A})) when it is
(\AIC{suc} \AB{n}).

\ExecuteMetaData[introduction.agda/introduction.tex]{replicate}

Second, we define \AF{map\textasciicircum{}-Tuple} which takes a function and
applies it to each one of the elements in a \AF{-Tuple}. Both the type of the
\AF{-Tuple} argument and the \AF{-Tuple} return type are refined based on the
pattern the natural number matches. In the second clause, this tells us the
\AF{-Tuple} argument is a pair, allowing us to match on it with the pair
constructor \AIC{\_,\_}.

\ExecuteMetaData[introduction.agda/introduction.tex]{mapntuple}

\paragraph{Dependent Record Types}

Record types can be dependent, i.e. the type of later fields can depend on that of
former ones. We define a \AR{Tuple} as a natural number (its \ARF{length}) together
with a (\ARF{length} \AF{-Tuple}) of values (its \ARF{content}).

\ExecuteMetaData[introduction.agda/introduction.tex]{tuple}

In Agda, as in all functional programming languages, we can define anonymous functions
by using a \AS{λ}-abstraction. Additionally, we can define anonymous (co)pattern-matching
functions by using (\AS{λ} \AK{where}) followed by an indented block of clauses.
We use here copattern-matching, that is to say that we define a \AR{Tuple} in terms
of the observations that one can make about it: we specify its length first, and
then its content. We use postfix projections (hence the dot preceding the field's name).

\ExecuteMetaData[introduction.agda/introduction.tex]{maptuple}

When record values are going to appear in types, it is often a good idea to define
them by copattern-matching: this prevents the definition from being unfolded eagerly
thus making the goal more readable during interactive development.

\paragraph{Strict Positivity} In order to rule out definitions leading to
inconsistencies, all datatype definitions need to be strictly positive.
Although a syntactic criterion originally (its precise definition is beyond
the scope of this discussion), Agda goes beyond by recording internally
whether functions use their arguments in a strictly positive manner.
This allows us to define types like rose trees where the subtrees of a
\AIC{node} are stored in a \AR{Tuple}, a function using its \AF{Set}
argument in a strictly positive manner.

\ExecuteMetaData[introduction.agda/introduction.tex]{rose}

\section{Sized Types and Termination Checking}
\label{sec:sizetermination}

If we naïvely define rose trees like above then we quickly realise that we cannot
re-use higher order functions on \AR{Tuple} to define recursive functions on \AD{Rose}.
As an example, let us consider \AF{map\textasciicircum{}Rose}. In the \AIC{node} case,
the termination checker does not realise that the partially applied recursive call
(\AF{map\textasciicircum{}Rose} \AB{f}) passed to \AF{map\textasciicircum{}Tuple}
will only ever be used on subterms. We need to use an unsafe \AK{TERMINATING} pragma
to force Agda to accept the definition.

\ExecuteMetaData[introduction.agda/introduction.tex]{maprose}

This is not at all satisfactory: we do not want to give up safety to write such a
simple traversal. The usual solution to this issue is to remove the level of
indirection introduced by the call to \AF{map\textasciicircum{}Tuple} by mutually
defining with \AF{map\textasciicircum{}Rose} an inlined version of
(\AF{map\textasciicircum{}Tuple} (\AF{map\textasciicircum{}Rose} \AB{f})).

\ExecuteMetaData[introduction.agda/introduction.tex]{inlinedmaprose}

This is, of course, still unsatisfactory: we need to duplicate code every
time we want to write a traversal! By using sized types, we can have a more
compositional notion of termination checking: the size of a term is reflected
in its type. No matter how many levels of indirection there are between the
location where we are peeling off a constructor and the place where the function
is actually called recursively, as long as the intermediate operations are
size-preserving we know that the recursive call will be legitimate.

Writing down the sizes explicitly, we get the following implementation. Note
that in (\AF{map\textasciicircum{}Tuple} (\AF{map\textasciicircum{}Rose} \AB{j} \AB{f})),
\AB{j} (bound in \AIC{node}) is smaller than \AB{i} and therefore the recursive
call is justified.

\ExecuteMetaData[introduction.agda/introduction.tex]{erose}
\ExecuteMetaData[introduction.agda/introduction.tex]{maperose}

In practice we make the size arguments explicit in the types but implicit in the
terms. This leads to programs that look just like our ideal implementation, with
the added bonus that we have now \emph{proven} the function to be total.

\ExecuteMetaData[introduction.agda/introduction.tex]{irose}
\ExecuteMetaData[introduction.agda/introduction.tex]{mapirose}

\section{Working with Indexed Families}
\label{sec:indexed-combinators}

On top of the constructs provided by the language itself, we can define various
domain specific languages (DSL) which give us the means to express ourselves
concisely. We are going to manipulate a lot of indexed families representing
scoped languages so we give ourselves a few combinators corresponding to the
typical operations we want to perform on them.

First, noticing that most of the time we silently thread the current scope, we lift
the function space pointwise with \AF{\_⇒\_}.

\ExecuteMetaData[shared/Stdlib.tex]{implication}

Second, the \AF{\_⊢\_} combinator makes explicit the \emph{adjustment} made to the
index by a function, conforming to the convention (see e.g. \cite{martin1982constructive})
of mentioning only context \emph{extensions} when presenting judgements and write
({\AB{f} \AF{⊢} \AB{P}}) where \AB{f} is the modification and \AB{P} the indexed
Set it operates on.

\ExecuteMetaData[shared/Stdlib.tex]{update}

Although it may seem surprising at first to define binary infix operators as having
arity three, they are meant to be used partially applied, surrounded by \AF{∀[\_]}
which turns an indexed Set into a Set by implicitly quantifying over the index.

\ExecuteMetaData[shared/Stdlib.tex]{forall}

We make \AF{\_⇒\_} associate to the right as one would expect and give it the
highest precedence level as it is the most used combinator. These combinators
lead to more readable type declarations.  For instance, the compact expression
\AF{∀[} \AF{suc} \AF{⊢} (\AB{P} \AF{⇒} \AB{Q}) \AF{⇒} \AB{R} \AF{]}
desugars to the more verbose type
\AS{∀} \{\AB{i}\} \AS{→} (\AB{P} (\AF{suc} \AB{i}) \AS{→} \AB{Q} (\AF{suc} \AB{i})) \AS{→} \AB{R} \AB{i}.


As the combinators act on the \emph{last} argument of any indexed family, this inform our
design: our notions of variables, languages, etc. will be indexed by their kind first and
scope second. This will be made explicit in the definition of \AF{─Scoped} in
\cref{fig:scoped}.
