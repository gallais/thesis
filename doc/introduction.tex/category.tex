\chapter{Introduction to Category Theory}
\label{introduction-category}

Although this thesis is not about category theory, some categorical
notions do show up. They help us expose the structure of the problem
and the solutions we designed. Hence this (short) introduction to
category theory focused on the notions that will be of use to us.
Computer scientists looking for a more substantial introduction
to category theory can refer to Pierce's little book~(\citeyear{DBLP:books/daglib/0069193}).

\section{What even is a Category?}

\begin{definition}\label{def:category}
A \textbf{category} \AB{ğ“’} is defined by a set of objects (written Obj(\AB{ğ“’}))
and a family of morphisms (written \AB{ğ“’}(\AB{A},\AB{B})) between any two
such objects \AB{A} and \AB{B} such that:
\begin{enumerate}
  \item For any object \AB{A}, we have a morphism $id_{\AB{A}}$ in {\AB{ğ“’}(\AB{A},\AB{A})}
  \item Given three objects \AB{A}, \AB{B}, and \AB{C}, and two morphisms
    \AB{f} in {\AB{ğ“’}(\AB{A},\AB{B})} and \AB{g} in {\AB{ğ“’}(\AB{B},\AB{C})},
    we have a unique morphism {(\AB{g} $âˆ˜_{\AB{ğ“’}}$ \AB{f})} in
    {\AB{ğ“’}(\AB{A},\AB{C})} corresponding to the composition
    of \AB{f} and \AB{g}.
  \item Composition is associative
  \item The appropriate identities are left and right neutral elements for composition
\end{enumerate}
\end{definition}

\begin{convention} When the reader should be able to reconstruct the
information from the context, we may write $id$ instead of $id_{\AB{A}}$
and $(\_âˆ˜\_)$ instead of $(\_âˆ˜_{\AB{ğ“’}}\_)$ respectively.
\end{convention}

\begin{example}[Sets and functions]
In this category called \Set, objects are sets and morphisms are total
functions between them. Identities and compositions are the usual notions
of identity and composition for functions.
\end{example}

\begin{example}[Families and index-respecting functions]
\label{example:familiescat}
Given a set \AB{I}, we define $\Set^I$ as the category whose objects
are families of type {(\AB{I} â†’ Set)} and whose morphisms between
two families \AB{P} and \AB{Q} are index preserving functions i.e.
functions of type {(âˆ€\AB{i} â†’ \AB{P} \AB{i} â†’ \AB{Q} \AB{i})}.
\end{example}

\section{Functors}

\begin{definition}[Functor]\label{def:functor}
A functor \AB{F} between two categories
\AB{ğ“’} and \AB{ğ““} is defined by its action on the objects and
morphisms of \AB{ğ“’}. It takes objects in \AB{ğ“’} to objects in
\AB{ğ““}, and morphisms in {\AB{ğ“’}(\AB{A},\AB{B})} to morphisms in
{\AB{ğ““}(\AB{F} \AB{A}, \AB{F} \AB{B})} such that the structure of
\AB{ğ“’} is preserved. In other words:
\begin{enumerate}
  \item {\AB{F} $id_{\AB{A}}$} is equal to $id_{\AB{F} \AB{A}}$
  \item {\AB{F} (\AB{g} $âˆ˜_{\AB{ğ“’}}$ \AB{f})} is equal to
      {(\AB{F} \AB{g} $âˆ˜_{\AB{ğ““}}$ \AB{F} \AB{f})}
\end{enumerate}
\end{definition}


\begin{definition}[Endofunctor]\label{def:endofunctor}
An endofunctor on a category \AB{ğ“’} is a functor
from \AB{ğ“’} to \AB{ğ“’}.
\end{definition}

\begin{example} Given a set \AB{I}, every function \AB{f} from \AB{I}
to itself induces an endofunctor on the category $\Set^I$
(cf. \cref{example:familiescat}).
We write {(\AB{f} âŠ¢\_)} for this functor, recalling the definition in
section~\ref{sec:indexed-combinators} and define its action on objects
and morphisms as follows:

\begin{itemize}
  \item Given an object \AB{P} (i.e. a predicate of type (\AB{I} â†’ Set)),
    we define {(\AB{f} âŠ¢ \AB{P})} to be the
    family {(Î»\AB{i} â†’ \AB{P} (\AB{f} \AB{i}))}
  \item Given a morphism \AB{prf} from \AB{P} to \AB{Q} (i.e. a function
    of type {(âˆ€\AB{i} â†’ \AB{P} \AB{i} â†’ \AB{Q} \AB{i})}),
    we define {(\AB{f} âŠ¢ \AB{prf})} to be
    the morphism {(Î» \AB{i} \AB{p} â†’ \AB{prf} (\AB{f} \AB{i}) \AB{p})}
\end{itemize}

The constraints spelt out in the definition of a functor are trivially verified.
\end{example}

\section{(Co)Monads}

\begin{definition}[Monad]
\label{def:monad}
A monad is an endofunctor \AB{T} on \AB{ğ“’} equipped with:
\begin{enumerate}
  \item For any object \AB{A}, a function $Î·_{\AB{A}}$ of type
    {\AB{ğ“’}(\AB{A}, \AB{T} \AB{A})} (the unit)
  \item For any objects \AB{A} and \AB{B}, a mapping $\_^*$ from
    {\AB{ğ“’}(\AB{A}, \AB{T} \AB{B})} to {\AB{ğ“’}(\AB{T} \AB{A}, \AB{T} \AB{B})}
    (the Kleisli extension)
\end{enumerate}

such that:

\begin{enumerate}
  \item For any object \AB{A}, $Î·_{\AB{A}}\,^*$ is equal to $id_{\AB{T} \AB{A}}$
  \item For any objects \AB{A} and \AB{B} and \AB{f} a morphism of type
    {\AB{ğ“’}(\AB{A}, \AB{T} \AB{B})}, $\AB{f}\,^* âˆ˜ Î·_{\AB{A}}$ is equal to \AB{f}
  \item For any objects \AB{A}, \AB{B}, \AB{C} and two morphisms
    \AB{f} in {\AB{ğ“’}(\AB{A}, \AB{T} \AB{B})} and \AB{g} in {\AB{ğ“’}(\AB{B}, \AB{T} \AB{C})},
    $(\AB{g}^* âˆ˜ \AB{f})^*$ is equal to $(\AB{g}^* âˆ˜ \AB{f}^*)$
\end{enumerate}
\end{definition}

\begin{example}[Maybe]\todo{}
\end{example}

\begin{example}[Expression with free variables]\todo{}
\end{example}

\section{Monads need not be Endofunctors}

Although monads are defined as endofunctors, we can relax this
constraint by studying Altenkirch, Chapman and Uustalu's
\emph{relative} monads instead~(\citeyear{Altenkirch2010,JFR4389}).

\begin{definition}[Relative Monad]
\label{def:relative-monad}
A monad relative to a functor \AB{V} from \AB{ğ“’} to \AB{ğ““}
is a functor \AB{T} from \AB{ğ“’} to \AB{ğ““} equipped with:
\begin{enumerate}
  \item For any object \AB{A}, a mapping \AB{pure}$_{\AB{A}}$ of type
    {\AB{ğ““}(\AB{V} \AB{A}, \AB{T} \AB{A})} (the unit)
  \item For any objects \AB{A} and \AB{B}, a mapping $\_^*$
    from {\AB{ğ““}(\AB{V} \AB{A}, \AB{T} \AB{B})}
    to {\AB{ğ““}(\AB{T} \AB{A}, \AB{T} \AB{A})} (the Kleisli extension)
\end{enumerate}

such that they verify similar constraints to the ones spelt out in the
definition of a monad (\ref{def:monad}).
\end{definition}
